# What we Learn?
- [What we Learn?](#what-we-learn)
  - [NumPy Basics](#numpy-basics)
  - [Memory Management in NumPy](#memory-management-in-numpy)
      - [View and Copies](#view-and-copies)
  - [Shapes and Axes](#shapes-and-axes)
  - [Broadcasting](#broadcasting)
  - [Slicing](#slicing)
    - [Basic Slicing](#basic-slicing)
    - [Advanced Slicing](#advanced-slicing)
  - [Examples](#examples)

## NumPy Basics

|Function| Meaning | Example| Result|
|:--|:--|:--|:--|
|`np.array([<list>])`|Creating an array from a list |	`np.array([[1,2],[2,4]])`	| `[[1 2] [2 4]]` | 
|`np.array([<list>], dtype='i')`|Creating an array from a list by specifying items type |	`x = np.zeros((3, 3), dtype='i')`	|  | 
|`.shape`|returning shape of array|`x.shape`|`(2,2)`|
|`.dtype`|showing the type of array items|`x.dtype`|`int64`|
|`.ndim`|returning the array dimension|`x.ndim`|`2`|
|`np.arrange(<number>)`|creating an array like `range`|`np.arrange(3)`|`[0,1,2]`|
|`np.random.rand(<dimension>)`|creating a random nD array|`np.random.rand(2,1,3)`|a random array (2,1,3) will be created|
|`np.random.random((<dimension>))`|creating a random nD array|`np.random.rand((2,1,3))`|a random array (2,1,3) will be created|
|`np.random.randint(LOW, HIGH, size=SIZE)`|creating a random 1D integer array|`np.random.rand((2,4,3))`|`[3 2 2]`|
|`.flatten()`|returns a copy of the array collapsed into one dimension|`np.zeros(2,2).flatten()`|`array([0., 0., 0., 0.])`|
|`.ravel()`|returns a view of the original array with a flattened shape|`np.zeros(2,2).flatten()`|`array([0., 0., 0., 0.])`|
|`np.zeros((<size>))`|creating zero matrix|`np.zeros((2,3))`||
|`np.ones((<size>))`|creating one matrix|`np.ones((1,3))`||
|`np.eye(<size>)`|creating eye matrix|`np.eye(4)`||
|`(<array>, <min>, <max>, out=None)`|used to limit (or "clip") the values in an array to a specified range|`clipped_arr = np.clip(np.array([1, 2, 3, 4, 5]), 2, 4)`|`[2 2 3 4 4]`|
|`* / - + == !=`|vectorization functions element wise|`x*y`||
|`np.dot(<array1,array2>) or @`|matrix multiplication|`x@y or np.dot(x,y) `||


- `np.array(['hello', 'world', 3])` --> by defining this, all items changed to `<U21` (unicode).
- Many mathematical functions can be found [here](https://numpy.org/doc/stable/reference/routines.math.html).
- Many statistics functions can be found [here](https://numpy.org/doc/stable/reference/routines.statistics.html).
- **Vectorization** is the process of performing the same operation in the same way for each element in an array. This removes `for` loops from your code but achieves the same result.
- All NumPy operations are vectorized, where you apply operations to the whole array instead of on each element individually, which increase the performance (compared to loop).
- **Broadcasting** is the process of extending two arrays of different shapes and figuring out how to perform a vectorized calculation between them. Remember, grades is an array of numbers of shape `(8,)` and change is a **scalar**, or single number, essentially with shape `(1,)`. In this case, NumPy adds the scalar to each item in the array and returns a new array with the results.

## Memory Management in NumPy
An instance of class `ndarray` consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps `N` integers into the location of an item in the block. The ranges in which the indices can vary is specified by the **shape** of the array. How many bytes each item takes and how the bytes are interpreted is defined by the data-type object associated with the array.
```python
x = np.array([1, 2, 3])
x.flags
---- ANS -----
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
```
> The `flags` attribute holds information about the memory layout of the array.
  > `C_CONTIGUOUS`: indicates whether the array was a C-style array. 
  > `F_CONTIGUOUS`: indicates whether the array was a Fortan-style array.
  - `C-Style array` means that, when moving through the array, the row index is incremented first, and then the column index is incremented. In the case of a multidimensional C-style array, the last dimension is incremented first, followed by the last but one, and so on.
  - `F-Style array` is said to have column-major indexing (R, Julia, and MATLAB use column-major arrays). This means that, when moving through the array, the first index (along the column) is incremented first.
  - `C-array` is faster in row-wise opertaions than `F-array`. However, `F-array` in column-wise.
> Strides are the indexing scheme in NumPy arrays, and indicate the number of bytes to jump to find the next element.
 ```python
> x = np.random.rand(2,3)
print(x.dtype)
print(x.shape)
print(x.strides)
-------- ANS -------
float64
(2, 3)
(24, 8)
# as you can see the array is c-array and accessing each item is 8 byte so for accesing the item in next row we need 8*3 

x = np.random.rand(2,3,4)
print(x.strides)
-------- ANS -------
(96, 32, 8)
# float 64 --> 
# accessing first dimension: 8 byte. 
# accesing second dimension: 8byte*4 = 32
# accesing third dimension: 8byte*4*3 = 96
 ```

#### View and Copies
There are primarily two ways of accessing data by slicing and indexing. They are called copies and views: 
 - you can either access elements directly from an array, 
 - or create a copy of the array that contains only the accessed elements. 
  
Since a view is a reference of the original array (in Python, all variables are references), modifying a view modifies the original array too. This is not true for copies.
```python
x = np.random.rand(100, 10)
y = x[:5, :] #view operation
np.may_share_memory(x, y) #are they sharing memory?
y[:] = 0 #this will change the x array as well.
--------- ANS --------- 
True

x = np.random.rand(100, 10)
y = np.empty([5, 10]) 
y[:] = x[:5, :] # copy operation
np.may_share_memory(x, y)
--------- ANS --------- 
False
```
## Shapes and Axes
All arrays have a property called `.shape` that returns a tuple of the size in each dimension.
```python

temperatures = np.array([
    29.3, 42.1, 18.8, 16.1, 38.0, 12.5,
    12.6, 49.9, 38.6, 31.3, 9.2, 22.2
]).reshape(2, 2, 3)

temperatures.shape
temperatures
np.swapaxes(temperatures, 1, 2)
--------- ANS ----------
(2, 2, 3)
array([[[29.3, 42.1, 18.8],
        [16.1, 38. , 12.5]],

       [[12.6, 49.9, 38.6],
        [31.3,  9.2, 22.2]]])
array([[[29.3, 16.1],
        [42.1, 38. ],
        [18.8, 12.5]],

       [[12.6, 31.3],
        [49.9,  9.2],
        [38.6, 22.2]]])
```
- The example above shows how important it is to know not only what shape your data is in but also which data is in which **axis**. In NumPy arrays, axes are zero-indexed and identify which dimension is which. For example, a two-dimensional array has a vertical axis (axis 0) and a horizontal axis (axis 1). Lots of functions and commands in NumPy change their behavior based on which axis you tell them to process.

```python
table = np.array([
    [5, 3, 7, 1, 2],
    [2, 6, 7 , 9 ,3],
    [1, 1, 1, 1, 8],
    [4, 3, 2, 0, 10],
])
table.max()
table.shape
table.max(axis=0)
table.max(axis=1)
------------ ANS ------------
10
(4,5)
array([5,6,7,9,10])
array([7,9,8,1 0])
```
- By default, `.max()` returns the largest value in the entire array. However, once you specify an axis, it performs that calculation for each set of values along that particular axis. For example, with an argument of `axis=0`, `.max() `selects the maximum value in each of the four vertical sets of values in table and returns an array that has been **flattened**, or aggregated into a one-dimensional array.

- For example, if a 2D array a has shape `(5,6)`, then you can access `a[0,0]` up to `a[4,5]`. Axis `0` is thus the first dimension (the "rows"), and axis `1` is the second dimension (the "columns"). In higher dimensions, where "row" and "column" stop really making sense, try to think of the axes in terms of the shapes and indices involved.

- If you do `.sum(axis=n)`, for example, then dimension `n` is collapsed and deleted, with each value in the new matrix equal to the sum of the corresponding collapsed values. For example, if b has shape `(5,6,7,8)`, and you do `c = b.sum(axis=2)`, then axis 2 (dimension with size 7) is collapsed, and the result has shape (5,6,8). Furthermore, `c[x,y,z]` is equal to the sum of all elements `b[x,y,:,z]`.

you can't reshape a `3x3` array to a `10x1` array. The total number of elements should be consistent before and after reshaping. Or, you might need to resize, but that's another story. Now, let's look at some shape manipulations:
```python
x = np.arange(24)
x
x.shape = 2, 3, -1
x
--------- ANS ----------
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

```
- The basic reshaping technique changes the `numpy.shape` attribute. In the preceding example, we have an array whose shape is `(24, 1)`, and after altering the shape attribute, we obtain an array of the same size but the shape has been changed to `2x3x4`.
-  Note that `-1` in a shape means the remaining shape size of the transferred array.
  
## Broadcasting
NumPy operations are mostly done element-wise, which requires two arrays in an operation to have the same shape; however, this doesn't mean that NumPy operations can't take two differently shaped arrays
NumPy provides the flexibility to broadcast a smaller-sized array across a larger one. But we can't broadcast the array to just about any shape. It needs to follow certain constrains; 
Broadcasting involves performing meaningful operations over two differently shaped arrays. However, inappropriate broadcasting might lead to an inefficient use of memory that slows down computation.
```python
a = np.array([1.0, 2.0, 3.0])
b = 2.0
b_prime = np.array([2.0, 2.0, 2.0])
a * b
a * b_prime
--------- ANS ---------
array([2., 4., 6.])
array([2., 4., 6.])
```
- We can think of the scalar `b` being stretched during the arithmetic operation into an array with the same shape as `a`. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible.
- The multiplication with `b` is more efficient than `b_prime`, because broadcasting moves less memory around during the multiplication (`b` is a scalar rather than an array).

> **General Broadcasting Rules**
> - Two arrays should be of equal dimensions, or
> - One of them is 1
``` python
x = np.array([[0, 0, 0], [10, 10, 10], [20, 20, 20]]) #(3,3)
y = np.array([1, 2, 3]) #(3,)
x + y #(3,3)
------------
#second example
x = np.array([[0], [10], [20]]) 
x.shape, y.shape
x + y
--------- ANS ----------
array([[ 1,  2,  3],
       [11, 12, 13],
       [21, 22, 23]])
((3, 1), (3,))
array([[ 1,  2,  3],
       [11, 12, 13],
       [21, 22, 23]])
```
- Broadcasting rule: the shape of `y` is translated to `3` by `1`; therefore, the second condition of the rule has been met. 
- In second example, the preceding example shows you how both `x` and `y` are broadcast. `x` is broadcast by the column, while `y` is broadcast by the row since both of them have dimension that are equal to 1 in terms of their shape. The second broadcasting condition has been met, and the new result array is a `3` by `3` array.

> A set of arrays is called “broadcastable” to the same shape if the above rules produce a valid result.

For example, if `a.shape` is `(5,1)`, `b.shape` is `(1,6)`, `c.shape` is `(6,)` and `d.shape` is `()` so that `d` is a scalar, then a, b, c, and d are all broadcastable to dimension (5,6); and
- `a` acts like a `(5,6)` array where `a[:,0]` is broadcast to the other columns,
- `b` acts like a `(5,6)` array where `b[0,:]` is broadcast to the other rows,
- `c` acts like a `(1,6)` array and therefore like a `(5,6)` array where `c[:]` is broadcast to every row, and finally,
- `d` acts like a `(5,6)` array where the single value is repeated.

## Slicing
`ndarrays` can be indexed using the standard Python `x[obj]` syntax, where `x` is the array and `obj` the selection. There are different kinds of indexing available depending on `obj`:

- Basic indexing
- Advanced indexing
- Field access.

### Basic Slicing
Here’s the difference: NumPy arrays use commas between axes, so you can index multiple axes in one set of square brackets.
```python
import numpy as np
x = [[1,2],[3,4]] 
y = np.random.randint(1,5, size=(2,2))
# you will see the same operation on list and array
x[1][1] #list indexing 
y[1,1] #array indexing
```
> Note that in Python, `x[(exp1, exp2, ..., expN)]` is equivalent to `x[exp1, exp2, ..., expN]`; the latter is just syntactic sugar for the former. 

Basic slicing extends Python’s basic concept of slicing to N dimensions. Basic slicing occurs when obj is a [slice](https://docs.python.org/3/library/functions.html#slice) object (constructed by `start:stop:step` notation inside of brackets), an integer, or a tuple of slice objects and integers. [Ellipsis](https://docs.python.org/3/library/constants.html#Ellipsis) and [newaxis](https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis) objects can be interspersed with these as well.
> All arrays generated by basic slicing are always views of the original array.
- You may use slicing to set values in the array, but (unlike lists) you can never grow the array. The size of the value to be set in `x[obj] = value` must be (broadcastable) to the same shape as `x[obj]`.
```python
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
a[1:7:2] #start frrom the first item - 7th is the last item with step 2
a = np.random.randint(10, size=(3, 4))
a[0].shape #shape of the first row
a[0:1].shape #shape of first and second row

---------- ANS ---------- 
array([1, 3, 5])
(4,)
(1,4)

--------------------- 
# np.array([2, 3]) has shape (2, ) and 
# is not broadcastable to (5, )
a[:5] = np.array([2, 3])
# 8 is broadcastable!
a[:5] = 8

```

There are some tools to facilitate the easy matching of array shapes with expressions and in assignments.
 - [Ellipsis](https://docs.python.org/3/library/constants.html#Ellipsis) expands to the number of `:` objects needed for the selection tuple to index all dimensions. In most cases, this means that the length of the expanded selection tuple is `x.ndim`. There may only be a single ellipsis present. 
 - ```python
    a = np.random.randint(10, size=(2, 3, 4, 5))
    a.ndim
    b = a[:, :, :, 3]
    c = a[..., 3]
    b.shape
    #both c and b view the same part of the array 
    # c using Ellipsis for easier expression
    ----------- ANS ----------
    (2, 3, 4)
    ```
 - Each [`newaxis`](https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis) object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the `newaxis` object in the selection tuple. `newaxis` is an alias for `None`, and `None` can be used in place of this with the same result.
 - ```python
    a = np.arange(5)
    a
    a[:, np.newaxis] + a[np.newaxis, :]
    ----------- ANS -----------
    array([0, 1, 2, 3, 4])
    array([[0, 1, 2, 3, 4],
          [1, 2, 3, 4, 5],
          [2, 3, 4, 5, 6],
          [3, 4, 5, 6, 7],
          [4, 5, 6, 7, 8]])
    ```



### Advanced Slicing
Advanced indexing is triggered when the selection object, obj, is a non-tuple sequence object, an `ndarray` (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool). There are two types of advanced indexing:
- Integer: Integer array indexing allows selection of arbitrary items in the array based on their N-dimensional index. Each integer array represents a number of indices into that dimension.
- Boolean: This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators.

> **Note:** Advanced indexing always returns a copy of the data (contrast with basic slicing that returns a view).
> Negative values are permitted in the index arrays and work as they do with single indices or slices:
```python
#integer indexing example
a = np.arange(10, 1, -1)
a
b = a[np.array([3, 3, 1, 8, -3])] #choosing index 3,3,1,8,-3 of array a 
# Negative values work as before
b
---------- ANS ----------
array([10,  9,  8,  7,  6,  5,  4,  3,  2])
array([7, 7, 9, 2, 4])
-------------------------
# Note that this will raise error as a is 1 dimensional
a[3, 3, 1, 8]  # (3, 3, 1, 8) is a tuple -> Basic indexing
```

```python
#bolean indexing example 
a = np.random.randint(10, size=(3, 4))
a
a[:, [True, False, True, False]]
a[[True, False, True], :]
---------- ANS ----------
array([[9, 3, 0, 6],
       [4, 2, 3, 0],
       [7, 4, 7, 8]])
array([[9, 0],
       [4, 3],
       [7, 7]])
array([[9, 3, 0, 6],
       [7, 4, 7, 8]])
```
A common use case for boolean indexing is filtering for desired element values. For example, one may wish to select all entries from an array which are not NaN:
```python
x = np.array([[1., 2.], [np.nan, 3.], [np.nan, np.nan]])
np.isnan(x)
x[~np.isnan(x)]
x[(~np.isnan(x)).nonzero()]
(~np.isnan(x)).nonzero()
---------- ANS ----------
(array([1, 2, 2]), array([0, 0, 1]))
array([1., 2., 3.])
array([1., 2., 3.])
(array([0, 0, 1]), array([0, 1, 1]))
-----------------------
x = np.array([1., -1., -2., 3])
x[x < 0] += 20
x
---------- ANS ----------
array([ 1., 19., 18.,  3.])
```
A **mask** is an array that has the exact same shape as your data, but instead of your values, it holds Boolean values: either `True` or `False`. You can use this mask array to index into your data array in nonlinear and complex ways. It will return all of the elements where the Boolean array has a True value.
```python
numbers = np.linspace(5, 50, 24, dtype=int).reshape(4, -1)
numbers
mask = numbers % 4 == 0
mask
numbers[mask]
---------- ANS ----------
array([[ 5,  6,  8, 10, 12, 14],
       [16, 18, 20, 22, 24, 26],
       [28, 30, 32, 34, 36, 38],
       [40, 42, 44, 46, 48, 50]])
array([[False, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False]])
array([ 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48])
---------- --- ----------
# how it's typically done
by_four = numbers[numbers % 4 == 0]
by_four
```
You’ll see an explanation of the new array creation tricks in input 2 in a moment, but for now, focus on the meat of the example. These are the important parts:

- **`mask = numbers % 4 == 0`** creates the mask by performing a **vectorized Boolean computation**, taking each element and checking to see if it divides evenly by four. This returns a mask array of the same shape with the element-wise results of the computation.
- **`numbers[mask]`** uses this mask to index into the original numbers array. This causes the array to lose its original shape, reducing it to one dimension, but you still get the data you’re looking for.
- **`by_four = numbers[numbers % 4 == 0]`** provides a more traditional, idiomatic masked selection that you might see in the wild, with an anonymous filtering array created inline, inside the selection brackets. This syntax is similar to usage in the R programming language.

## Examples
- Example 1 (Curving Test Grades) - This example shows that using Numpy array ease and speed up many mathematical and statistics processes. It takes advantages of vectorization and broadcasting.
  ```python
  import numpy as np 

  curve_center = 80 
  grades = np.random.randint(0, 100, 10)

  def curve(grades):
      average_grades = grades.mean()
      change = curve_center - average_grades
      new_grades = grades + change

      return np.clip(new_grades, grades, 100)

  print(grades)
  print(curve(grades))
  ----------- ANS -----------
  [36 31 39 46 10 67 35 41  1 50]
  [80.4  75.4  83.4  90.4  54.4 100 79.4  85.4  45.4  94.4]
  ```
- Example 2: Implementing a Maclaurin Series
  - $e^x = \sum _{n=0} ^{\infty} \frac{x^n}{n!} = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + ...$
  - Using NumPy allows you to keep closer to a one-to-one representation from equation to code.
  ```python
  import numpy as np 
  from math import e, factorial

  fac = np.vectorize(factorial) #vectorizing factorial function

  def e_x (x, terms=10):
      n = np.arange(terms)
      return np.sum((x ** n) / fac(n))

  print("Actual:", e ** 3)
  print("N (terms)\tMaclaurin\tError")
  for n in range(1, 14):
      maclaurin = e_x(3, terms=n)
      print(f"{n}\t\t{maclaurin:.03f}\t\t{e**3 - maclaurin:.03f}")
  ----------- ANS -----------
  Actual: 20.085536923187664
  N (terms)       Maclaurin       Error
  1               1.000           19.086
  2               4.000           16.086
  3               8.500           11.586
  4               13.000          7.086
  5               16.375          3.711
  6               18.400          1.686
  7               19.412          0.673
  8               19.846          0.239
  9               20.009          0.076
  ```