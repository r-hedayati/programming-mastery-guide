# What we Learn?

- [What we Learn?](#what-we-learn)
  - [NumPy Basics](#numpy-basics)
  - [Memory Management in NumPy](#memory-management-in-numpy)
      - [View and Copies](#view-and-copies)
  - [Shapes and Axes](#shapes-and-axes)
    - [Broadcasting](#broadcasting)
  - [Indexing](#indexing)
    - [Slicing](#slicing)
    - [Basic Slicing](#basic-slicing)
    - [Advanced Indexing](#advanced-indexing)
  - [Examples](#examples)
  - [Transposing, Sorting, and Concatenating](#transposing-sorting-and-concatenating)
  - [](#)

## NumPy Basics

- **Array:** A collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together.
- **NumPy:** A Python library used for working with arrays. It also has functions for working in the domain of linear algebra, fourier transform, and matrices.
- **ndarray:** A NumPy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.
- list vs ndarray: 
  - **List:** A list is the Python equivalent of an array, but it is resizeable and can contain elements of different types.
  - **ndarray:** An ndarray is a fixed-size array in memory that contains data of the same type, such as integers or floating-point values.
  - **list** requires more memory as it stores the object and the reference to the object, while **ndarray** stores only the object.
  - **ndarray** is faster than **list** because it is fixed-size and homogeneous.
  - **ndarray** is more convenient than **list** because it has a lot of built-in functions for linear algebra and other mathematical operations.

|Function| Meaning | Example| Result|
|:--|:--|:--|:--|
|`np.array([<list>])`|Creating an array from a list |	`np.array([[1,2],[2,4]])`	| `[[1 2] [2 4]]` | 
|`np.array([<list>], dtype='i')`|Creating an array from a list by specifying items type |	`x = np.zeros((3, 3), dtype='i')`	|  | 
|`.shape`|returning shape of array|`x.shape`|`(2,2)`|
|`.dtype`|showing the type of array items|`x.dtype`|`int64`|
|`.ndim`|returning the array dimension|`x.ndim`|`2`|
|`np.arrange(<number>)`|creating an array like `range`|`np.arrange(3)`|`[0,1,2]`|
|`np.linspace(<start>, <stop>, <num>)`|creating an array with `num` elements from `start` to `stop`|`np.linspace(0, 10, 5)`|`[0. 2.5 5. 7.5 10.]`|
`np.diag(<array>)`|extracting the diagonal of an array|`np.diag(np.array([[1,2],[3,4]]))`|`[1 4]`|
|`np.random.rand(<dimension>)`|creating a random nD array|`np.random.rand(2,1,3)`|a random array (2,1,3) will be created|
|`np.random.random((<dimension>))`|creating a random nD array|`np.random.rand((2,1,3))`|a random array (2,1,3) will be created|
|`np.random.randint(LOW, HIGH, size=SIZE)`|creating a random 1D integer array|`np.random.rand((2,4,3))`|`[3 2 2]`|
|`.flatten()`|returns a copy of the array collapsed into one dimension|`np.zeros(2,2).flatten()`|`array([0., 0., 0., 0.])`|
|`.ravel()`|returns a view of the original array with a flattened shape|`np.zeros(2,2).flatten()`|`array([0., 0., 0., 0.])`|
|`np.zeros((<size>))`|creating zero matrix|`np.zeros((2,3))`||
|`np.ones((<size>))`|creating one matrix|`np.ones((1,3))`||
|`np.eye(<size>)`|creating eye matrix|`np.eye(4)`||
|`(<array>, <min>, <max>, out=None)`|used to limit (or "clip") the values in an array to a specified range|`clipped_arr = np.clip(np.array([1, 2, 3, 4, 5]), 2, 4)`|`[2 2 3 4 4]`|
|`* / - + == !=`|vectorization functions element wise|`x*y`||
|`np.dot(<array1,array2>) or @`|matrix multiplication|`x@y or np.dot(x,y) `||


- `np.array(['hello', 'world', 3])` --> by defining this, all items changed to `<U21` (unicode).
- Many mathematical functions can be found [here](https://numpy.org/doc/stable/reference/routines.math.html).
- Many statistics functions can be found [here](https://numpy.org/doc/stable/reference/routines.statistics.html).
- **Vectorization** is the process of performing the same operation in the same way for each element in an array. This removes `for` loops from your code but achieves the same result.
  - In order to better understand the concept of array shapes, you can think of a 1D array as a list of numbers, a 2D array as a matrix, a 3D array as a cube, and so on.
  - Also, when we say "axis = 0", we mean the first dimension of the array. When we say "axis = 1", we mean the second dimension of the array, and so on.
- **All NumPy operations are vectorized**, where you apply operations to the whole array instead of on each element individually, which increase the performance (compared to loop).
- **Broadcasting** is the process of extending two arrays of different shapes and figuring out how to perform a vectorized calculation between them. Remember, grades is an array of numbers of shape `(8,)` and change is a **scalar**, or single number, essentially with shape `(1,)`. In this case, NumPy adds the scalar to each item in the array and returns a new array with the results.


## Memory Management in NumPy

An instance of class `ndarray` consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps `N` integers into the location of an item in the block. The ranges in which the indices can vary is specified by the **shape** of the array. How many bytes each item takes and how the bytes are interpreted is defined by the data-type object associated with the array.

```python
x = np.array([1, 2, 3])
x.flags
---- ANS -----
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
```
> The `flags` attribute holds information about the memory layout of the array.
  > `C_CONTIGUOUS`: indicates whether the array was a C-style array. 
  > `F_CONTIGUOUS`: indicates whether the array was a Fortan-style array.

  - `C-Style array` means that, when moving through the array, the row index is incremented first, and then the column index is incremented. In the case of a multidimensional C-style array, the last dimension is incremented first, followed by the last but one, and so on.
  - `F-Style array` is said to have column-major indexing (R, Julia, and MATLAB use column-major arrays). This means that, when moving through the array, the first index (along the column) is incremented first.
  - `C-array` is faster in row-wise operations than `F-array`. However, `F-array` in column-wise.

> Strides are the indexing scheme in NumPy arrays, and indicate the number of bytes to jump to find the next element.
 ```python
> x = np.random.rand(2,3)
print(x.dtype)
print(x.shape)
print(x.strides)
-------- ANS -------
float64
(2, 3)
(24, 8)
# as you can see the array is c-array and accessing each item is 8 byte so for accesing the item in next row we need 8*3 

x = np.random.rand(2,3,4)
print(x.strides)
-------- ANS -------
(96, 32, 8)
# float 64 --> 
# accessing first dimension: 8 byte. 
# accesing second dimension: 8byte*4 = 32
# accesing third dimension: 8byte*4*3 = 96
 ```

#### View and Copies
There are primarily two ways of accessing data by slicing and indexing. They are called copies and views: 

 - you can either access elements directly from an array, 
 - or create a copy of the array that contains only the accessed elements. 
  
Since a view is a reference of the original array (in Python, all variables are references), modifying a view modifies the original array too. This is not true for copies.
```python
x = np.random.rand(100, 10)
y = x[:5, :] #view operation
np.may_share_memory(x, y) #are they sharing memory?
y[:] = 0 #this will change the x array as well.
--------- ANS --------- 
True

x = np.random.rand(100, 10)
y = np.empty([5, 10]) 
y[:] = x[:5, :] # copy operation
np.may_share_memory(x, y)
--------- ANS --------- 
False
```
## Shapes and Axes
All arrays have a property called `.shape` that returns a tuple of the size in each dimension.
```python

temperatures = np.array([
    29.3, 42.1, 18.8, 16.1, 38.0, 12.5,
    12.6, 49.9, 38.6, 31.3, 9.2, 22.2
]).reshape(2, 2, 3)

temperatures.shape
temperatures
np.swapaxes(temperatures, 1, 2)
--------- ANS ----------
(2, 2, 3)
array([[[29.3, 42.1, 18.8],
        [16.1, 38. , 12.5]],

       [[12.6, 49.9, 38.6],
        [31.3,  9.2, 22.2]]])
array([[[29.3, 16.1],
        [42.1, 38. ],
        [18.8, 12.5]],

       [[12.6, 31.3],
        [49.9,  9.2],
        [38.6, 22.2]]])
```

- The example above shows how important it is to know not only what shape your data is in but also which data is in which **axis**. In NumPy arrays, **axes are zero-indexed** and identify which dimension is which. For example, a two-dimensional array has a vertical axis (axis 0) and a horizontal axis (axis 1). Lots of functions and commands in NumPy change their behavior based on which axis you tell them to process.

```python
table = np.array([
    [5, 3, 7, 1, 2],
    [2, 6, 7 , 9 ,3],
    [1, 1, 1, 1, 8],
    [4, 3, 2, 0, 10],
])
table.max()
table.shape
table.max(axis=0)
table.max(axis=1)
------------ ANS ------------
10
(4,5)
array([5,6,7,9,10])
array([7,9,8,10])
```

- By default, `.max()` returns the largest value in the entire array. However, once you specify an axis, it performs that calculation for each set of values along that particular axis. For example, with an argument of `axis=0`, `.max() `selects the maximum value in each of the four vertical sets of values in table and returns an array that has been **flattened**, or aggregated into a one-dimensional array.

- For example, if a 2D array a has shape `(5,6)`, then you can access `a[0,0]` up to `a[4,5]`. Axis `0` is thus the first dimension (the "rows"), and axis `1` is the second dimension (the "columns"). In higher dimensions, where "row" and "column" stop really making sense, try to think of the axes in terms of the shapes and indices involved.

- If you do `.sum(axis=n)`, for example, then dimension `n` is collapsed and deleted, with each value in the new matrix equal to the sum of the corresponding collapsed values. For example, if b has shape `(5,6,7,8)`, and you do `c = b.sum(axis=2)`, then axis 2 (dimension with size 7) is collapsed, and the result has shape (5,6,8). Furthermore, `c[x,y,z]` is equal to the sum of all elements `b[x,y,:,z]`.

you can't reshape a `3x3` array to a `10x1` array. The total number of elements should be consistent before and after reshaping. Or, you might need to resize, but that's another story. Now, let's look at some shape manipulations:
```python
x = np.arange(24)
x
x.shape = 2, 3, -1
x
--------- ANS ----------
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

```
- `np.arrange((start, stop, step))` is used to create an array of numbers from `start` to `stop` with a step size of `step`.
- `np.linespace(start, stop, num)` is used to create an array of `num` numbers from `start` to `stop`. It is better to use `np.linespace` when you know the number of elements you want in the array.
- The basic reshaping technique changes the `numpy.shape` attribute. In the preceding example, we have an array whose shape is `(24, 1)`, and after altering the shape attribute, we obtain an array of the same size but the shape has been changed to `2x3x4`.
- Note that `-1` in a shape means the remaining shape size of the transferred array.
  
### Broadcasting

NumPy's operations are mostly done **element-wise**, which requires two arrays in an operation to have the **same shape**; however, this doesn't mean that NumPy operations can't take two differently shaped arrays
**NumPy provides the flexibility to broadcast a smaller-sized array across a larger one**. But we can't broadcast the array to just about any shape. It needs to follow certain constrains; 
Broadcasting involves performing meaningful operations over two differently shaped arrays. However, inappropriate broadcasting might lead to an inefficient use of memory that slows down computation.

```python
a = np.array([1.0, 2.0, 3.0])
b = 2.0
b_prime = np.array([2.0, 2.0, 2.0])
a * b
a * b_prime
--------- ANS ---------
array([2., 4., 6.])
array([2., 4., 6.])
```

- We can think of the scalar `b` being stretched during the arithmetic operation into an array with the same shape as `a`. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible.
- The multiplication with `b` is more efficient than `b_prime`, because **broadcasting moves less memory around** during the multiplication (`b` is a scalar rather than an array).

> **General Broadcasting Rules**
> Two arrays should be of equal dimensions, or one of them is 1
``` python
x = np.array([[0, 0, 0], [10, 10, 10], [20, 20, 20]]) #(3,3)
y = np.array([1, 2, 3]) #(3,)
x + y #(3,3)
------------
#second example
x = np.array([[0], [10], [20]]) 
x.shape, y.shape
x + y
--------- ANS ----------
array([[ 1,  2,  3],
       [11, 12, 13],
       [21, 22, 23]])
((3, 1), (3,))
array([[ 1,  2,  3],
       [11, 12, 13],
       [21, 22, 23]])
```

- Broadcasting rule: the shape of `y` is translated to `3` by `1`; therefore, the second condition of the rule has been met. 
- In second example, the preceding example shows you how both `x` and `y` are broadcast. `x` is broadcast by the column, while `y` is broadcast by the row since both of them have dimension that are equal to 1 in terms of their shape. The second broadcasting condition has been met, and the new result array is a `3` by `3` array.

> A set of arrays is called “broadcastable” to the same shape if the above rules produce a valid result.

For example, if `a.shape` is `(5,1)`, `b.shape` is `(1,6)`, `c.shape` is `(6,)` and `d.shape` is `()` so that `d` is a scalar, then a, b, c, and d are all broadcastable to dimension (5,6); and

- `a` acts like a `(5,6)` array where `a[:,0]` is broadcast to the other columns,
- `b` acts like a `(5,6)` array where `b[0,:]` is broadcast to the other rows,
- `c` acts like a `(1,6)` array and therefore like a `(5,6)` array where `c[:]` is broadcast to every row, and finally,
- `d` acts like a `(5,6)` array where the single value is repeated.


## Indexing

NumPy arrays can be indexed with slices, but also with boolean or integer arrays (masks). This method is called fancy indexing. It creates copies not views.


### Slicing
`ndarrays` can be indexed using the standard Python `x[obj]` syntax, where `x` is the array and `obj` the selection. There are different kinds of indexing available depending on `obj`:

- Basic indexing
- Advanced indexing
- Field access.

### Basic Slicing
Here’s the difference: NumPy arrays use commas between axes, so you can index multiple axes in one set of square brackets.
```python
import numpy as np
x = [[1,2],[3,4]] 
y = np.random.randint(1,5, size=(2,2))
# you will see the same operation on list and array
x[1][1] #list indexing 
y[1,1] #array indexing
```
> Note that in Python, `x[(exp1, exp2, ..., expN)]` is equivalent to `x[exp1, exp2, ..., expN]`; the latter is just syntactic sugar for the former.

Basic slicing extends Python’s basic concept of slicing to N dimensions. Basic slicing occurs when obj is a [slice](https://docs.python.org/3/library/functions.html#slice) object (constructed by `start:stop:step` notation inside of brackets), an integer, or a tuple of slice objects and integers. [Ellipsis](https://docs.python.org/3/library/constants.html#Ellipsis) and [newaxis](https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis) objects can be interspersed with these as well.
> All arrays generated by basic slicing are always views of the original array.

- You may use slicing to set values in the array, but (unlike lists) you can never grow the array. The size of the value to be set in `x[obj] = value` must be (broadcastable) to the same shape as `x[obj]`.

```python
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
a[1:7:2] #start frrom the first item - 7th is the last item with step 2
a = np.random.randint(10, size=(3, 4))
a[0].shape #shape of the first row
a[0:1].shape #shape of first and second row

---------- ANS ---------- 
array([1, 3, 5])
(4,)
(1,4)

--------------------- 
# np.array([2, 3]) has shape (2, ) and 
# is not broadcastable to (5, )
a[:5] = np.array([2, 3])
# 8 is broadcastable!
a[:5] = 8

```

There are some tools to facilitate the easy matching of array shapes with expressions and in assignments.

 - [Ellipsis](https://docs.python.org/3/library/constants.html#Ellipsis) expands to the number of `:` objects needed for the selection tuple to index all dimensions. In most cases, this means that the length of the expanded selection tuple is `x.ndim`. There may only be a single ellipsis present. 
 - ```python
    a = np.random.randint(10, size=(2, 3, 4, 5))
    a.ndim
    b = a[:, :, :, 3]
    c = a[..., 3]
    b.shape
    #both c and b view the same part of the array 
    # c using Ellipsis for easier expression
    ----------- ANS ----------
    (2, 3, 4)
    ```
 - Each [`newaxis`](https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis) object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the `newaxis` object in the selection tuple. `newaxis` is an alias for `None`, and `None` can be used in place of this with the same result.
 - ```python
    a = np.arange(5)
    a
    a[:, np.newaxis] + a[np.newaxis, :]
    ----------- ANS -----------
    array([0, 1, 2, 3, 4])
    array([[0, 1, 2, 3, 4],
          [1, 2, 3, 4, 5],
          [2, 3, 4, 5, 6],
          [3, 4, 5, 6, 7],
          [4, 5, 6, 7, 8]])
    ```



### Advanced Indexing
Advanced indexing is triggered when the selection object, obj, is a non-tuple sequence object, an `ndarray` (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool). There are two types of advanced indexing:

- Integer: Integer array indexing allows selection of arbitrary items in the array based on their N-dimensional index. Each integer array represents a number of indices into that dimension.
- Boolean: This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators.

> **Note:** Advanced indexing always returns a copy of the data (contrast with basic slicing that returns a view).
> Negative values are permitted in the index arrays and work as they do with single indices or slices:

```python
#integer indexing example
a = np.arange(10, 1, -1)
a
b = a[np.array([3, 3, 1, 8, -3])] #choosing index 3,3,1,8,-3 of array a 
# Negative values work as before
b
---------- ANS ----------
array([10,  9,  8,  7,  6,  5,  4,  3,  2])
array([7, 7, 9, 2, 4])
-------------------------
# Note that this will raise error as a is 1 dimensional
a[3, 3, 1, 8]  # (3, 3, 1, 8) is a tuple -> Basic indexing
```

```python
#bolean indexing example 
a = np.random.randint(10, size=(3, 4))
a
a[:, [True, False, True, False]]
a[[True, False, True], :]
---------- ANS ----------
array([[9, 3, 0, 6],
       [4, 2, 3, 0],
       [7, 4, 7, 8]])
array([[9, 0],
       [4, 3],
       [7, 7]])
array([[9, 3, 0, 6],
       [7, 4, 7, 8]])
```
A common use case for boolean indexing is filtering for desired element values. For example, one may wish to select all entries from an array which are not NaN:
```python
x = np.array([[1., 2.], [np.nan, 3.], [np.nan, np.nan]])
np.isnan(x)
x[~np.isnan(x)]
x[(~np.isnan(x)).nonzero()]
(~np.isnan(x)).nonzero()
---------- ANS ----------
(array([1, 2, 2]), array([0, 0, 1]))
array([1., 2., 3.])
array([1., 2., 3.])
(array([0, 0, 1]), array([0, 1, 1]))
-----------------------
x = np.array([1., -1., -2., 3])
x[x < 0] += 20
x
---------- ANS ----------
array([ 1., 19., 18.,  3.])
```
A **mask** is an array that has the exact same shape as your data, but instead of your values, it holds Boolean values: either `True` or `False`. You can use this mask array to index into your data array in nonlinear and complex ways. It will return all of the elements where the Boolean array has a True value.
```python
numbers = np.linspace(5, 50, 24, dtype=int).reshape(4, -1)
numbers
mask = numbers % 4 == 0
mask
numbers[mask]
---------- ANS ----------
array([[ 5,  6,  8, 10, 12, 14],
       [16, 18, 20, 22, 24, 26],
       [28, 30, 32, 34, 36, 38],
       [40, 42, 44, 46, 48, 50]])
array([[False, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False]])
array([ 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48])
---------- --- ----------
# how it's typically done
by_four = numbers[numbers % 4 == 0]
by_four
```
You’ll see an explanation of the new array creation tricks in input 2 in a moment, but for now, focus on the meat of the example. These are the important parts:

- **`mask = numbers % 4 == 0`** creates the mask by performing a **vectorized Boolean computation**, taking each element and checking to see if it divides evenly by four. This returns a mask array of the same shape with the element-wise results of the computation.
- **`numbers[mask]`** uses this mask to index into the original numbers array. This causes the array to lose its original shape, reducing it to one dimension, but you still get the data you’re looking for.
- **`by_four = numbers[numbers % 4 == 0]`** provides a more traditional, idiomatic masked selection that you might see in the wild, with an anonymous filtering array created inline, inside the selection brackets. This syntax is similar to usage in the R programming language.

## Examples

- Example 1 (Curving Test Grades) - This example shows that using Numpy array ease and speed up many mathematical and statistics processes. It takes advantages of vectorization and broadcasting.
  ```python
  import numpy as np 

  curve_center = 80 
  grades = np.random.randint(0, 100, 10)

  def curve(grades):
      average_grades = grades.mean()
      change = curve_center - average_grades
      new_grades = grades + change

      return np.clip(new_grades, grades, 100)

  print(grades)
  print(curve(grades))
  ----------- ANS -----------
  [36 31 39 46 10 67 35 41  1 50]
  [80.4  75.4  83.4  90.4  54.4 100 79.4  85.4  45.4  94.4]
  ```
- Example 2: Implementing a Maclaurin Series
  - $e^x = \sum _{n=0} ^{\infty} \frac{x^n}{n!} = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + ...$
  - Using NumPy allows you to keep closer to a one-to-one representation from equation to code.
  ```python
  import numpy as np 
  from math import e, factorial

  fac = np.vectorize(factorial) #vectorizing factorial function

  def e_x (x, terms=10):
      n = np.arange(terms)
      return np.sum((x ** n) / fac(n))

  print("Actual:", e ** 3)
  print("N (terms)\tMaclaurin\tError")
  for n in range(1, 14):
      maclaurin = e_x(3, terms=n)
      print(f"{n}\t\t{maclaurin:.03f}\t\t{e**3 - maclaurin:.03f}")
  ----------- ANS -----------
  Actual: 20.085536923187664
  N (terms)       Maclaurin       Error
  1               1.000           19.086
  2               4.000           16.086
  3               8.500           11.586
  4               13.000          7.086
  5               16.375          3.711
  6               18.400          1.686
  7               19.412          0.673
  8               19.846          0.239
  9               20.009          0.076
  ```

## Transposing, Sorting, and Concatenating

Transposing is a common operation in linear algebra where the column and row indices of each element are swapped. For example, the first row becomes the first column, the second row becomes the second column, and so on. In NumPy, you can transpose a matrix using the `T` attribute of an array object.

```python
a = np.array([[1, 2], [3, 4]])
a
a.T #transposing the array
a.transpose() #another way to transpose the array
---------  ANS ---------
array([[1, 2],
       [3, 4]])
array([[1, 3],
       [2, 4]])
```

- `np.sort()`: This function sorts the elements of an array along a specified axis. The `axis` parameter is optional. If you don't specify the axis, the function will sort the elements along the last axis.
  
  ```python
       a = np.array([[3, 2], [10, -1]])
       np.sort(a) #sort along the last axis (axis=1)
       np.sort(a, axis=None) #sort the flattened array
       np.sort(a, axis=0) #sort along the first axis
       ---- ANS ----
       array([[ 2,  3],
              [-1, 10]])
       array([-1,  2,  3, 10])
       array([[ 3, -1],
              [10,  2]])
       ```

- `np.concatenate()`: This function concatenates two or more arrays along a specified axis. The `axis` parameter is optional. If you don't specify the axis, the function will concatenate the arrays along the first axis.
  
  ```python
       a = np.array([[1, 2], [3, 4]])
       b = np.array([[5, 6]])
       np.concatenate((a, b), axis=0) #concatenate along the first axis
       np.concatenate((a, b.T), axis=1) #concatenate along the second axis
       np.contactenate((a, b), axis=None) #concatenate the flattened arrays
       ---- ANS ----
       array([[1, 2],
              [3, 4],
              [5, 6]])
       array([[1, 2, 5],
              [3, 4, 6]])
       array([1, 2, 3, 4, 5, 6])
       ```
- `np.vstack()`: This function stacks arrays in sequence vertically (row-wise). This is equivalent to concatenation along the first axis after 1-D arrays of shape `(N,)` have been reshaped to `(1,N)`. Rebuild arrays divided by `vsplit`.
  
  ```python
       a = np.array([[1, 2], [3, 4]])
       b = np.array([[5, 6]])
       np.vstack((a, b))
       ---- ANS ----
       array([[1, 2],
              [3, 4],
              [5, 6]])
       ```
- `np.hstack()`: This function stacks arrays in sequence horizontally (column-wise). This is equivalent to concatenation along the second axis after 1-D arrays of shape `(N,)` have been reshaped to `(N,1)`. Rebuild arrays divided by `hsplit`.
       
     ```python
         a = np.array([[1], [2], [3]])
         b = np.array([[4], [5], [6]])
         np.hstack((a, b))
         ---- ANS ----
         array([[1, 4],
                  [2, 5],
                  [3, 6]])
         ```
- The difference between `np.concatenate()`, `np.vstack()`, and `np.hstack()` is that `np.concatenate()` can concatenate arrays along any axis, while `np.vstack()` and `np.hstack()` can only concatenate arrays along the first and second axes, respectively.


## Optimizing Storage: NumPy Data Types

In NumPy, though, there’s a little more detail that needs to be covered. NumPy uses C code under the hood to optimize performance, and it can’t do that unless all the items in an array are of the same type. That doesn’t just mean the same Python type. They have to be the same underlying C type, with the same shape and size in bits!

NumPy provides a wide range of data types to be used with arrays. You can specify the data type using the `dtype` parameter. The default data type is `float`.

A data type object describes interpretation of fixed block of memory corresponding to an array, depending on the following aspects:
- Type of data (integer, float, Python object, etc.)
- Size of data
- Byte order (little-endian or big-endian)
- In case of structured type, the names of fields, data type of each field, and part of the memory block taken by each field
- If the data type is a sub-array, its shape and data type

```python
x = np.array([1, 2, 3], dtype='f')
x.dtype
x = np.array([1, 2, 3], dtype='>i4')
x.dtype
-------- ANS --------
dtype('float32')
dtype('>i4') #-->it means 4 byte integer with big-endian
```
- `dt.itemsize`: This attribute returns the size of the data type in bytes.
- `dt.name`: This attribute returns the name of the data type.
- `dt.type`: This attribute returns the data type object.

A structured data type is a data type that describes a collection of fields, each with a specific data type. These fields are stored in a contiguous block of memory. Structured data types are defined using the `numpy.dtype` class.

```python
dt = np.dtype([('name', np.unicode_, 16), ('grades', np.float64, (2,))])
dt['name']
dt['grades']
--------- ANS ---------
dtype('<U16')
dtype(('<f8', (2,)))
```

- `dt = np.dtype(np.int32)` - This creates a data type object that represents a 32-bit integer.

- `np.array([1, 2, 3], dtype=float32)` - This creates an array of integers with the float32 data type. In memory, each integer will be represented as a 32-bit floating-point number.

Strings in NumPy are a little different from Python strings. In Python, strings are arrays of characters. In NumPy, strings are arrays of fixed-size characters. This means that every string in a NumPy array has the same length. If you try to insert a string that is too long, it will be truncated to fit the fixed length.

```python
names = np.array(['Alice', 'Bob', 'Cathy'], dtype='str')
names
names.itemsize
names[0] = 'Alicia finds a cat'
names  
--------- ANS ---------
array(['Alice', 'Bob', 'Cathy'], dtype='<U5')
20
array(['Alici', 'Bob', 'Cathy'], dtype='<U5')
# the string is truncated to fit the fixed length
```

Structured arrays are useful when you need to work with more complex data types. For example, you might have a dataset that contains information about people, including their names, ages, and weights. You could store this data in a structured array with fields for each piece of information.

```python
people = np.array([
       ('Alice', 25, 85.0),
       ('Bob', 45, 95.5)],
       dtype=[('name', 'U10'),
       ('age', 'i4'),
       ('weight', 'f8')])
people
people['name']
people['age']
people['weight']
--------- ANS ---------
array([('Alice', 25, 85. ), ('Bob', 45, 95.5)],
      dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f8')])
array(['Alice', 'Bob'], dtype='<U10')
array([25, 45], dtype=int32)
array([85. , 95.5])
```
The above example is a structured array with three fields: name, age, and weight. The name field is a Unicode string with a maximum length of 10 characters. The age field is a 32-bit integer, and the weight field is a 64-bit floating-point number.
This represents SQL like Query on Structured Data Type, where NumPy gives a super-powerful combination of mask-based filtering based on a field and field-based selection.

```SQL
SELECT name FROM people WHERE age < 30
```

```python
people[people['age'] < 30]['name']
```

- Both above queries are equivalent, but the NumPy version is more concise and readable. It also has the advantage of being able to be used in a programmatic context, where the SQL query would have to be embedded in a string and executed as a separate operation.

Dates and times in NumPy are represented by the `numpy.datetime64` data type. This data type encodes dates as 64-bit integers, where the integer represents the number of days since a reference date. The reference date is `1970-01-01`, also known as the Unix epoch.

```python
date = np.array('2020-01-01', dtype='datetime64')
date
date + np.arange(12)
--------- ANS ---------
array('2020-01-01', dtype='datetime64[D]')
array(['2020-01-01', '2020-01-02', '2020-01-03', '2020-01-04',
       '2020-01-05', '2020-01-06', '2020-01-07', '2020-01-08',
       '2020-01-09', '2020-01-10', '2020-01-11', '2020-01-12'],
      dtype='datetime64[D]')
```

- all mathematical operations on dates are done in days. If you want to work with smaller units, you can use the `timedelta64` data type, which represents a duration of time.
- Conversion between `numpy.datetime64` and `datetime` objects can be done using the `np.datetime64` and `astype` functions.

## 