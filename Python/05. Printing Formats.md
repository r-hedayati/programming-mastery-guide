<a class="anchor" id="reading_input_from_the_keyboard"></a>

## Reading Input From the Keyboard

Programs often need to obtain data from the user, usually by way of input from the keyboard. The simplest way to accomplish this in Python is with `input()`.
```python
#Reads a line of input from the keyboard.
user_name = input('please write your name')
```

`input()` always returns a string. If you want a numeric type, then you need to convert the string to the appropriate type with the `int()`, `float()`, or `complex()` built-in functions:
```python 
n = int(input('Enter a number: '))
```

<a class="anchor" id="writing_output_to_the_console"></a>

## Writing Output to the Console
You can display program data to the console in Python with `print()`.
- By default, `print()` separates each object by a single space and appends a newline to the end of the output:
- Any type of object can be specified as an argument to `print()`. If an object isn’t a string, then `print()` converts it to an appropriate string representation displaying it.
### print() arguments:
- `end` argument is a good approach for what would be print at the end of the line `print(<>, end=<>)`:
    - example:
  
        ```python
        for item in range(100):
            if item % 10 == 0 :
                end = '\n'
            else:
                end = ' ' 
            print(item, end=end)
        ans=
        0
        1 2 3 4 5 6 7 8 9 10
        11 12 13 14 15 16 17 18 19 20
        21 22 23 24 25 26 27 28 29 30
        31 32 33 34 35 36 37 38 39 40
        41 42 43 44 45 46 47 48 49 50
        51 52 53 54 55 56 57 58 59 60
        61 62 63 64 65 66 67 68 69 70
        71 72 73 74 75 76 77 78 79 80
        81 82 83 84 85 86 87 88 89 90
        91 92 93 94 95 96 97 98 99 
        ```
- `sep` argument will seperate each item of a `print`:
    - example:
    
        ```python
        print('Ali', 'Hasan', 'Ahmad', sep='/')
        ans = Ali/Hasan/Ahmad
        ```
- `logurur` is a powerful library in python for `logging`. (read more about it in [here](https://github.com/Delgan/loguru))

## Python String Formatting 
1. **`.format`** :As you’ve seen, when you call Python’s `.format()` method, the `<template>` string contains replacement fields. These indicate where in the template to insert the arguments to the method. A replacement field consists of three components:

> `{[<name>][!<conversion>][:<format_spec>]}`

    These components are interpreted as follows:

   |Component | Meaning|
   |:--|:--|
   |`<name>` | Specifies the source of the value to be formatted |
   |`<conversion>` | Indicates which standard Python function to use to perform the conversion |
   |`<format_spec>` | Specifies more detail about how the value should be converted |
   - Examples for `<name>` component: 
       ```python
         x, y, z = 1, 2, 3 
         {0}, {1}, {baz}'.format(x, y, baz=z)
         a = ['foo', 'bar', 'baz']
         '{0[0]}, {0[2]}'.format(a)
         '{my_list[0]}, {my_list[2]}'.format(my_list=a)
        ```
   - Examples for `<conversion>` component:
       > Converting to string: `{0!s}'.format(42)`
       > Converting to printable version: `{0!r}'.format(42)`
       > Converting to ascii:  `{0!a}'.format(42)`
   - Examples for `<format>` component: `<format_spec>` represents the guts of the Python `.format()` method’s functionality. It contains information that exerts fine control over how values are formatted prior to being inserted into the template string. The general form is this:
   
   `:[[<fill>]<align>][<sign>][#][0][<width>][<group>][.<prec>][<type>]`

   |Subcomponent | Effect| 
   |:--|:--|
   |`:` | Separates the <format_spec> from the rest of the replacement field| 
   |`<fill>` | Specifies how to pad values that don’t occupy the entire field width|
   |`<align>` | Specifies how to justify values that don’t occupy the entire field width|
   |`<sign>` | Controls whether a leading sign is included for numeric values|
   |`#` | Selects an alternate output form for certain presentation types|
   |`0` | Causes values to be padded on the left with zeros instead of ASCII space characters|
   |`<width>` | Specifies the minimum width of the output|
   |`<group>` | Specifies a grouping character for numeric output|
   |`.<prec>` | Specifies the number of digits after the decimal point for floating-point presentation types, and the maximum output width for string presentations types |
   |`<type>` | Specifies the presentation type, which is the type of conversion performed on the corresponding argument|
   
```python
    '{:f}'.format(2.1) --> '2.100000'
    '{0:<8s}'.format('foo') --> 'foo     '
    '{0:>8d}'.format(123) --> '     123'
    '{0:^10s}'.format('foo') --> '   foo    '
    '{0:->8s}'.format('foo') --> '-----foo'
    '{0:b}, {0:#b}'.format(16) --> '10000, 0b10000'
    '{0:08.1f}'.format(12.3) --> '000012.3'
    '{0:,d}'.format(1234567) --> '1,234,567'
    '{0:_x}'.format(0xae123fcc8ab2) --> 'ae12_3fcc_8ab2'
    '{0:8.2f}'.format(1234.5678) --> ' 1234.57'  
    
    print('{0} {1} cost ${2}'.format(6, 'bananas', 1.74)) #positinal argument
    print('{} {} cost ${}'.format(6, 'bananas', 1.74)) #positinal argument
    print('{x} {y} cost ${z}'.format(x=6, 'y=bananas', z=1.74)) #keyword argument
    {2}.{1}.{0}/{0}{0}.{1}{1}.{2}{2}'.format('foo', 'bar', 'baz')
```

2. **`f-string`**: Code using `str.format()` is much more easily readable than code using `%`-formatting, but `str.format()` can still be quite verbose when you are dealing with multiple parameters and longer strings. Take a look at this: 

```python
quantity = 6
item = 'bananas'
price = 1.74
# .format example
'There are {quantity} {item}, each of which costs ${price}'.format(quantity=quantity, item=item, price=price)
# f-string example
f'There are {quantity} {item}, each of which costs ${price}.'
```
More examples: 
- The interpreter treats the remainder of the f-string—anything not inside curly braces—just as it would an ordinary string. :
```python 
s={bar}, print(f'foo\n{s}\nbaz')
```
- Arithmetic expressions: 
```python
quantity, item, price = 6, 'bananas', 1.74
print(f'Price per item is ${price/quantity}')
```
- Indexing, slicing, and key references:
```python
a = ['foo', 'bar', 'baz']
d = {'foo': 1, 'bar': 2}
print(f'First item in list a = {a[0]}')
print(f'Last two items in list a = {a[-2:]}')
print(f"Dict value for key 'bar' is {d['bar']}")
```
- Function and method calls
```python
a = ['foo', 'bar', 'baz', 'qux', 'quux']
print(f'List a has {len(a)} items')
print(f'--- {a[0].upper()} ---')
```
- Conditional expressions:
```python
x = 3
y = 7
print(f'The larger of {x} and {y} is {x if x > y else y}')
```
- It also supports all of the formating which mentions in `.format`: 

```python
f'{<expr>!<conversion>:<format_spec>}'

'{0!<conversion>:<format_spec>}'.format(<expr>)
```
Example:
```python
n = 123
s = 'foo'
f'{n:=+8}'
f'{s:*^8}'
```

In relative speed factors, that’s (f-string is the fatest):
    
- f-string: `1.0`
- concatenate string: `1.33`
- `.join()` sequence of strings: `1.73`
- `%s` formatting operator: `2.40`
- `.format()` method: `3.62`
- `Template()` method: `11.48`