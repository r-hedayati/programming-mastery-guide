The previous tutorials in this series have emphasized the importance of **objects** in Python. Objects are everywhere! Virtually everything that your Python program creates or acts on is an object.
An **assignment statement** creates a **symbolic name** that you can use to reference an object. The statement `x = 'foo'` creates a symbolic name `x` that refers to the string object `'foo'`.
<a class="anchor" id="namespaces_in_python"></a>
## Namespaces in Python
A namespace is a collection of currently defined symbolic names along with information about the object that each name references. You can think of a namespace as a dictionary in which the keys are the object names and the values are the objects themselves. Each key-value pair maps a name to its corresponding object.

> Namespaces are one honking great idea—let’s do more of those!
> 
> — _The Zen of Python, by Tim Peters_

As Tim Peters suggests, namespaces aren’t just great. They’re honking great, and Python uses them extensively. In a Python program, there are four types of namespaces:

1. Built-In
2. Global
3. Enclosing
4. Local

<a class="anchor" id="the_built-in_namespace"></a>
### The Built-In Namespace
The **built-in namespace** contains the names of all of Python’s built-in objects. These are available at all times when Python is running. You can list the objects in the built-in namespace with the following command:
```python
import builtins
# dir(__builtins__)
```
You’ll see some objects here that you may recognize from previous sections—for example, the `StopIteration` exception, built-in functions like `max()` and `len()`, and object types like `int` and `str`.
The Python interpreter creates the built-in namespace when it starts up. This namespace remains in existence until the interpreter terminates.

<a class="anchor" id="the_global_namespace"></a>
### The Global Namespace
The **global namespace** contains any names defined at the level of the main program. Python creates the global namespace when the main program body starts, and it remains in existence until the interpreter terminates.
Strictly speaking, this may not be the only global namespace that exists. The interpreter also creates a global namespace for any **module** that your program loads with the import statement. Further information on main functions and modules in Python will be covered later after OOP.

<a class="anchor" id="the_local_and_enclosing_namespaces"></a>
### The Local and Enclosing Namespaces
As you learned in the previous tutorial on functions, the interpreter creates a new namespace whenever a function executes. That namespace is local to the function and remains in existence until the function terminates.

```python
def f():
    print('Start f()')

    def g():
        print('Start g()')
        print('End g()')
        return

    g()

    print('End f()')
    return


f()
```
In this example, function `g()` is defined within the body of `f()`. Here’s what’s happening in this code:
- **Lines 1 to 12** define `f()`, the **enclosing** function.
- **Lines 4 to 7** define `g()`, the **enclosed** function.
- On **line 15**, the main program calls `f()`.
- On **line 9**, `f()` calls `g()`.
When the main program calls `f()`, Python creates a new namespace for `f()`. Similarly, when `f()` calls `g()`, `g()` gets its own separate namespace. The namespace created for g() is the **local namespace**, and the namespace created for `f()` is the **enclosing namespace**.

Each of these namespaces remains in existence until its respective function terminates. Python might not immediately reclaim the memory allocated for those namespaces when their functions terminate, but all references to the objects they contain cease to be valid.

<a class="anchor" id="variable_scope"></a>
## Variable Scope
The existence of multiple, distinct namespaces means several different instances of a particular name can exist simultaneously while a Python program runs. As long as each instance is in a different namespace, they’re all maintained separately and won’t interfere with one another.
But that raises a question: Suppose you refer to the name `x` in your code, and `x` exists in several namespaces. How does Python know which one you mean?
The answer lies in the concept of **scope**. The scope of a name is the region of a program in which that name has meaning. The interpreter determines this at runtime based on where the name definition occurs and where in the code the name is referenced.
To return to the above question, if your code refers to the name `x`, then Python searches for `x` in the following namespaces in the order shown:

1. **Local**: If you refer to `x` inside a function, then the interpreter first searches for it in the innermost scope that’s local to that function.
2. **Enclosing**: If `x` isn’t in the local scope but appears in a function that resides inside another function, then the interpreter searches in the enclosing function’s scope.
3. **Global**: If neither of the above searches is fruitful, then the interpreter looks in the global scope next.
4. **Built-in**: If it can’t find x anywhere else, then the interpreter tries the built-in scope.
This is the **LEGB rule** as it’s commonly called in Python literature (although the term doesn’t actually appear in the Python documentation). The interpreter searches for a name from the inside out, looking in the **l**ocal, **e**nclosing, **g**lobal, and finally the **b**uilt-in scope.
If the interpreter doesn’t find the name in any of these locations, then Python raises a `NameError` exception.

```python
x = 'global'

def f():
    x = 'enclosing'

    def g():
        x = 'local'
        print(x)

    g()

f()
```

<a class="anchor" id="python_namespace_dictionaries"></a>
## Python Namespace Dictionaries

Earlier in this tutorial, when namespaces were first introduced, you were encouraged to think of a namespace as a dictionary in which the keys are the object names and the values are the objects themselves. In fact, for global and local namespaces, that’s precisely what they are! Python really does implement these namespaces as dictionaries.
> **Note:** The built-in namespace doesn’t behave like a dictionary. Python implements it as a module. We will cover modules later.

Python provides built-in functions called `globals()` and `locals()` that allow you to access global and local namespace dictionaries.

<a class="anchor" id="the_`globals()`_function"></a>
### The `globals()` function
The built-in function `globals()` returns a reference to the current global namespace dictionary. You can use it to access the objects in the global namespace. Here’s an example of what it looks like when the main program starts:

```python
x = 'foo'
globals()
print(----'next'----)
globals()['x']
----Answer----
{'__name__': '__main__',
 '__doc__': 'Automatically created module for IPython interactive environment',
 '__package__': None,
 '__loader__': None,
 '__spec__': None,
 '__builtin__': <module 'builtins' (built-in)>,
 '__builtins__': <module 'builtins' (built-in)>,
 '_ih': ['', "x = 'foo'\nglobals()"],
 '_oh': {},
 '_dh': [PosixPath('/Users/rhedayati/workspace/GitHub_Repositories/rhedayati/learningProgrammingNotes/Python')],
 'In': ['', "x = 'foo'\nglobals()"],
 'Out': {},
 'get_ipython': <bound method InteractiveShell.get_ipython of <ipykernel.zmqshell.ZMQInteractiveShell object at 0x7fbfe80727c0>>,
 'exit': <IPython.core.autocall.ZMQExitAutocall at 0x7fbfe808c340>,
 'quit': <IPython.core.autocall.ZMQExitAutocall at 0x7fbfe808c340>,
 '_': '',
 '__': '',
 '___': '',
 '_i': '',
 '_ii': '',
 '_iii': '',
 '_i1': "x = 'foo'\nglobals()",
 'x': 'foo'}

----'next'----
'foo'
--------------
```

<a class="anchor" id="the_`locals()`_function"></a>
### The `locals()` function
Python also provides a corresponding built-in function called `locals()`. It’s similar to `globals()` but accesses objects in the local namespace instead:

```python
def f(x, y):
    s = 'foo'
    print(locals())
f(10, 0.5)
----Answer----
{'x': 10, 'y': 0.5, 's': 'foo'}
--------------
```
When called within `f()`, `locals()` returns a dictionary representing the function’s local namespace. Notice that, in addition to the locally defined variable `s`, the local namespace includes the function parameters `x` and `y` since these are local to `f()` as well.
If you call `locals()` outside a function in the main program, then it behaves the same as `globals()`.

<a class="anchor" id="modify_variables_out_of_scope"></a>
## Modify Variables Out of Scope
Earlier in this series, in the tutorial on user-defined Python functions, you learned that argument passing in Python is a bit like pass-by-value and a bit like pass-by-reference. Sometimes a function can modify its argument in the calling environment by making changes to the corresponding parameter, and sometimes it can’t:

- An **immutable** argument can never be modified by a function.
- A **mutable** argument can’t be redefined wholesale, but it can be modified in place.
A similar situation exists when a function tries to modify a variable outside its local scope. A function can’t modify an immutable object outside its local scope at all

<a class="anchor" id="best_practices"></a>
### Best Practices
Even though Python provides the `global` and `nonlocal` keywords, it’s not advisable to use them.
When a function modifies data outside the local scope, either with the `global` or `nonlocal` keyword or by directly modifying a mutable type in place, it’s a kind of side effect similar to when a function modifies one of its arguments. Widespread modification of global variables is generally considered unwise, not only in Python but also in other programming languages.
In Python, using the `global` keyword at least makes it explicit that the function is modifying a global variable. In many languages, a function can modify a global variable just by assignment, without announcing it in any way. This can make it very difficult to track down where global data is being modified.
All in all, modifying variables outside the local scope usually isn’t necessary. There’s almost always a better way, usually with function return values.