# Conditional Statements
<a class="anchor" id="conditional_statement"></a>

In a Python program, the if statement is how you perform this sort of decision-making. It allows for **conditional** execution of a statement or group of statements based on the value of an expression.
## if Statement
```python
if <expr>:
    <statement>
```
- If `<expr>` is true (evaluates to a value that is “truthy”), then `<statement>` is executed. If `<expr>` is false, then `<statement>` is skipped over and not executed.


- Here, all the statements at the matching indentation level (lines 2 to 5) are considered part of the same block. The entire block is executed if `<expr>` is true, or skipped over if `<expr>` is false. Either way, execution proceeds with `<following_statement>` (line 6) afterward.

```python
if <expr>:
    <statement>
    <statement>
    ...
    <statement>
<following_statement>
```
- Sometimes, you want to evaluate a condition and take one path if it is true but specify an alternative path if it is not. This is accomplished with an `else` clause:

```python
if <expr>:
    <statement(s)>
else:
    <statement(s)>
```

- There is also syntax for branching execution based on several alternatives. For this, use one or more `elif` (short for `else if`) clauses. Python evaluates each `<expr>` in turn and executes the suite corresponding to the first that is true. If none of the expressions are true, and an `else` clause is specified, then its suite is executed:

```python
if <expr>:
    <statement(s)>
elif <expr>:
    <statement(s)>
elif <expr>:
    <statement(s)>
    ...
else:
    <statement(s)>
```

- Turnary `if` statement: In its simplest form, the syntax of the conditional expression is as follows:

```python
<expr1> if <conditional_expr> else <expr2>
```

## Notes
- Using a lengthy `if/elif/else` series can be a little inelegant, especially when the actions are simple statements like `print()`. In many cases, there may be a more Pythonic way to accomplish the same thing. Here’s one possible alternative to the example above using f-string:

```python
name = 'Joe'

if name in ['Fred', 'Xander', 'Joe', 'Arnold']:
    print(f'Hello {name}')
else:
    print("I don't know who you are!")
```

- An `if` statement with `elif` clauses uses short-circuit evaluation, analogous to what you saw with the `and` and `or` operators. Once one of the expressions is found to be true and its block is executed, none of the remaining expressions are tested. This is demonstrated below. The second expression contains a division by zero, and the third references an undefined variable `var`. Either would raise an error, but neither is evaluated because the first condition specified is true.

```python
if 'a' in 'bar':
    print('foo')
elif 1/0:
    print("This won't happen")
elif var:
    print("This won't either")
```

#  While Loop (indefinite iterations)
<a class="anchor" id="while_loop"></a>

**Iteration** means executing the same block of code over and over, potentially many times. A programming structure that implements iteration is called a **loop**.

In programming, there are two types of iteration, indefinite and definite:

- With **indefinite iteration**, the number of times the loop is executed isn’t specified explicitly in advance. Rather, the designated block is executed repeatedly as long as some condition is met.

- With **definite iteration**, the number of times the designated block will be executed is specified explicitly at the time the loop starts.

The format of a rudimentary `while` loop is shown below:
    
```python
while <expr>:
    <statement(s)>
```

## some while loop examples
```python
n = 0
while n > 0:
    n -= 1
    print(n)
    
a = ['foo', 'bar', 'baz']
while a:
    print(a.pop(-1))   
```
## Loop Control Statements

In each example you have seen so far, the entire body of the `while` loop is executed on each iteration. Python provides two keywords that terminate a loop iteration prematurely:

- The Python `break` statement immediately terminates a loop entirely. Program execution proceeds to the first statement following the loop body.

- The Python `continue` statement immediately terminates the current loop iteration. Execution jumps to the top of the loop, and the controlling expression is re-evaluated to determine whether the loop will execute again or terminate.


When using loop control statements, keep the following in mind:

- Use the `break` statement sparingly. It can make loops less predictable and harder to understand.
- Use the `continue` statement when you need to skip over part of a loop for a certain condition.
- Use the `pass` statement as a placeholder for future code. It reminds you or indicates to others that a piece of code is intentionally left blank at the moment.

### `else` clause in while loop
Python allows an optional `else` clause at the end of a `while` loop. This is a unique feature of Python, not found in most other programming languages. The syntax is shown below:

```python
while <expr>:
    <statement(s)>
else:
    <additional_statement(s)>
```
The `<additional_statement(s)>` specified in the `else` clause will be executed when the while loop terminates (all iterations done).
### Infinite loops
You can also specify multiple break statements in an infinite loop:
```python
while True:
    if <expr1>:  # One condition for loop termination
        break
    ...
    if <expr2>:  # Another termination condition
        break
    ...
    if <expr3>:  # Yet another
        break
```

### nested loops

A `break` or `continue` statement found within nested loops applies to the nearest enclosing loop:

```python
while <expr1>:
    statement
    statement

    while <expr2>:
        statement
        statement
        break  # Applies to while <expr2>: loop

    break  # Applies to while <expr1>: loop
```

#  For Loop (definite iterations)
<a class="anchor" id="for_loop"></a>

Definite iteration loops are frequently referred to as ‍`for` loops because for is the keyword that is used to introduce them in nearly all programming languages, including Python.

**loop format in Python**
- Collection-based or iterator-based type of loop iterates over a collection of objects, rather than specifying numeric values or conditions. In Python, **iterable** means an object can be used in iteration. If an object is iterable, it can be passed to the built-in Python function `iter()`, which returns something called an **iterator**. 

```python
for i in <collection>
    <loop body>
```
-  string, list, tuple, dict, set, and frozenset are iterable types .
- `break`, `continue`, `else` cluse are usable in `for` too.

## A glance to Iterators
- An iterator is essentially a value producer that yields successive values from its associated iterable object. The built-in function `next()` is used to obtain the next value from in iterator. In this example, `a` is an iterable list and `itr` is the associated iterator, obtained with `iter()`. Each `next(itr)` call obtains the next value from `itr`.
```python
a = ['foo', 'bar', 'baz']
itr = iter(a)
itr
next(itr) #run it multiple times
---- ANS ----
'foo'
'bar'
```
- You can only obtain values from an iterator in one direction. You can’t go backward. There is no `prev()` function. But you can define two independent iterators on the same iterable object:
```python
a = ['foo', 'bar', 'baz']
itr1 = iter(a)
itr2 = iter(a)
```
- `itertools` is a powerful library for playing with iterators which would easy the problems.

|**Term**|**Meaning** |
|:--|:--|
|**Iteration**| The process of looping through the objects or items in a collection |
|**Iterable**| An object (or the adjective used to describe an object) that can be iterated over |
|**Iterator**| The object that produces successive items or values from its associated iterable |
|**`iter()`**|	The built-in function used to obtain an iterator from an iterable |

## some examples

```python
d = {'foo': 1, 'bar': 2, 'baz': 3}
for k in d: #d.values(), d.keys(), d.items()
    print(k)
----- ANS -----
foo
bar
baz
```
```python
for i, j in [(1, 2), (3, 4), (5, 6)]:
    print(i, j)
----- ANS -----
1 2
3 4
5 6
```
```python
for n in range(1, 10, 2):
    print(n)
----- ANS -----
1
3
5
7
9
```
- `range()` function generates a sequence of numbers. It is commonly used for looping a specific number of times in `for` loops.
    ```python
        range(stop)
        range(start, stop)
        range(start, stop, step)
    ```
- `enumerate()` function is used to iterate over a sequence while keeping track of the item number. It returns a tuple in the form `(item_number, item)`.
  ```python
    for i, v in enumerate(['tic', 'tac', 'toe']):
        print(i, v)
    ----- ANS -----
    0 tic
    1 tac
    2 toe
  ```



