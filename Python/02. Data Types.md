
> Almost everything in Python is an object, with its properties and methods.
- In Python, every object has its own unique identity. The `id()` function returns the identity of an object. The identity of an object is unique and constant for the object during its lifetime.
- `is` operator is used to compare the identity of two objects. It returns `True` if the identity of two objects is the same. Otherwise, it returns `False`.
- `is` and `==` operators are different. `is` operator compares the identity of two objects(memory location), whereas `==` operator compares the values of two objects.

# Strings
<a class="anchor" id="string_manipulation"></a>

Strings (a flat sequence) are objects that contain sequences of character data, which made them a immutable data structure (cannot change -- change them by slicing).

```python
s = 'Hello, World!'

#multiline string
s = """
Hello, World!
This is a multiline string.
"""
```

## String Manipulation

|Operator |	Example |	Meaning |	Result |
|:--|:--|:--|:--|
|`+` |	`"Ali"+"Ahmad"` |	**Concating** | `AliAhmad` |
|`*` |	`"Ali" * 3` |	**Multiple Copies** | `AliAliAli` |
|`in` or `not in` |	`"Ali" in "Ali eat an apple"` |	**searching a specified string** | `True` if `Ali` is in the sentence. `False` otherwise |

## Built-in String Functions

|Function | Description| Example | Result |
|:--|:--|:--|:--|
|`chr()` | Converts an integer to a character | `ord('?')`| `63`|
|`ord()` | Converts a character to an integer |`chr(97)`|`"a"`|
|`len()` | Returns the length of a string |`len("I am a string.")`|`14`|
|`str()` | Returns a string representation of an object |`str(49.2)`|`"49.2"`|

## Slicing

if `s = 'foobar' `, then we have:

| Example | Result |
|:--|:--|
| `s[1:3]`| `'oo'`|
|`s[len(s)-1]==s[-1]`|`'r'`|
|`s[2:len(s)]`|`obar`|
|`s[-5:-2]`|`'oob'`|
|`s[0:6:2]==s[:6:2]`|`foa`|
|`s[5:0:-2]==s[5::-2]`|`'rbo'`|
|`s[::-1]`|`'raboof'`|

**Notes**

- we can reverse a string using `s[::-1]` &rarr; `'raboof'`
- string cannot be modified using `s[3]='x'`, we can change it using `s[:3]+'x'+s[4:]`


## String Methods
|Method | Description| Example | Result |
|:--|:--|:--|:--|
|`capitalize()` | Converts the first character to upper case |`"hello".capitalize()`|`"Hello"`|
|`lower()` | Converts a string into lower case |`"Hello".lower()`|`"hello"`|
|`upper()` | Converts a string into upper case |`"Hello".upper()`|`"HELLO"`|
|`title()` | Converts the first character of each word to upper case |`"hello world".title()`|`"Hello World"`|
|`center()` | Returns a centered string |`"Hello".center(20)`|`"       Hello        "`|
|`count()` | Returns the number of times a specified value occurs in a string |`"Hello".count('l')`|`2`|
|`find()` | Searches the string for a specified value and returns the position of where it was found |`"Hello".find('e')`|`1`|
|`replace()` | Returns a string where a specified value is replaced with a specified value |`"Hello".replace('l', 'x')`|`"Hexxo"`|
|`split()` | Splits the string at the specified separator, and returns a list |`"Hello, World".split(',')`|`['Hello', ' World']`|
|`strip()` | Returns a trimmed version of the string |`" Hello, World ".strip()`|`"Hello, World"`|
|`join()` | Joins the elements of an iterable to the end of the string |`", ".join(['Hello', 'World'])`|`"Hello, World"`|
|`startswith()` | Returns true if the string starts with the specified value |`"Hello, World".startswith('H')`|`True`|
|`endswith()` | Returns true if the string ends with the specified value |`"Hello, World".endswith('d')`|`True`|
|`isalnum()` | Returns True if all characters in the string are alphanumeric |`"Hello123".isalnum()`|`True`|
|`isalpha()` | Returns True if all characters in the string are in the alphabet |`"Hello".isalpha()`|`True`|
|`isdigit()` | Returns True if all characters in the string are digits |`"123".isdigit()`|`True`|


## Some Notes{#string_notes}

-**.fromat()**: `print('Hello, {}'.format(name))` is a method that formats string into a nicer output. 
  - **.fromat()**: `print('n is {} and m is {}'.format(n, m))`

- **f-string**: `f'Hello, {name}'` is a new way of formatting strings in Python. It is more powerful and faster than the older format strings.
  - **f-string:** `print(f'n is {n} and m is {m}'`
- **string is immutable**: strings are immutable, so we cannot change them. However, we can change them by slicing.
  - `s = "h" + s[1:]`
- **escape sequences**: Escape sequences allow you to include special characters in strings. To denote an escape sequence, Python uses the backslash (`\`) followed by another character.
  - `\n` for new line
  - `\t` for tab
  - `\\` for backslash
  - `\'` for single quote
  - `\"` for double quote
  - `\b` for backspace
  - `\r` for carriage return

# Lists
<a class="anchor" id="list_manipulation"></a>

a list (a container sequence) is a collection of arbitrary objects. Each object saves in the list as a pointer (refrence). The important characteristics of Python lists are as follows:

- Lists are **ordered**. `[1,2] != [2,1]`
- Lists can **contain any** arbitrary **objects**. 
  - `my_list=['Hi', 1021, False, 29.34, 'Bye', '21', [1,2,3], math]` 
  - in this example `math` is a function
- List elements can be **accessed** by **index**. 
  - `my_list[1] == 1021` 
  - all **string manipulation** can be done with lists too. 
  - `len`, `min`, `max`, `sum`, `sort`, `reverse`, `index`, `count`, `append`, `extend`, `insert`, `remove`, `pop`, `clear`, `copy`
- Lists can be nested to arbitrary depth.
  -  `x = ['a', ['bb', ['ccc', 'ddd'], 'ee', 'ff'], 'g']` 
  -  we can reach to each element using indexing: `x[1][1][1]=='ccc'`
- Lists are **mutable**. 
  - `my_list[0]='Salam'`
- Lists are **dynamic**.

## Notes{#list_notes}
```python
# different ways of defining a list
my_list = []
my_list = [1,2,3,4,5] 
my_list = list('12345')
my_list = list(range(1,6))
my_list = [i for i in range(1,6)]
#list from other types
my_list = list('Hello, World!')
```
| Description| Example | Result |
|:--|:--|:--|
| reversing a list | `my_list[::-1]`| `[5,4,3,2,1]`|
| finding an item |`'Hi' in my_list`|`False`|
|deleting an item |`del my_list[0]`|`[2,3,4,5]`|
|deleting multiple item|`del my_list[1:3]` or `my_list[1:3]=[]`|`[1,4,5]`|
|appending an item to the end of the list |`my_list.append('Ali')`|`[1,2,3,4,5,'Ali']`|
|inserting a value w/o changing list|`my_list[2:2]=23.11`|`[1,23.11,2,3,4,5]`|
|prepending and appending|`['asad']+my_list+['54','34']`| `['asad',1,2,3,4,5,'54','34']`
|retrieving index|`my_list.index(2)`|`3`|
|unpacking list values|`print(*my_list)`|`1 2 3 4 5`|
| adding a list to a list | `my_list.extend([20, 30])` | `[1,2,3,4,5,20,30]`|
| inserting an element at a specific index | `my_list.insert(2, 20)` | `[1,2,20,3,4,5]`|
| removing an element from a list | `my_list.remove(3)` | `[1,2,4,5]`|
| removing the last element | `my_list.pop()` | `[1,2,3,4]`|
| reversing a list | `my_list.reverse()` | `[5,4,3,2,1]`|
| sorting a list | `my_list.sort()` | `[1,2,3,4,5]`|


- **list vs string**: if we have a list name `a` `and b=a[:]` &rarr; `b` will be a copy of list `a` (with unique address). However, in strings, this will not happen because they are immutable.
- **append() method vs appending**: the `append()` method is faster than appending using concating. In concating the whole list will be copied into new address.
- a list must be concatenated with another list, so if you want to add only one element, you need to specify it as a singleton list: `my_list+=[20]`

# Tuples
<a class="anchor" id="tuple_manipulation"></a>

Tuples are identical to lists (read-only version of list) in all respects, except for the following properties:

- Tuples are defined by enclosing the elements in parentheses (`()`) instead of square brackets `[]`). `my_tuple=(1,2,3)`
- Tuples are **immutable**.
- indexing and slicing are the same as lists.
- Membership testing (`in`) is faster with tuples than with lists.
- Count and index methods are available in tuples (`count()`, `index()`).
- Sorting and reversing are faster in tuples than in lists.

**When use Tuple over List**: 
- Program execution is faster when manipulating a tuple than it is for the equivalent list. (for big data)
- Sometimes you don’t want data to be modified. 
- They can be used in keys of dictionaries.


**Packing and unpacking**
```python
t = (1, 32, 91, 21)
(s1, s2, s3, s4) = t
```
or 
```python
(s1, s2, s3, s4) = (1, 32, 91, 21)
```
- then `s1` will be `1`, `s2` will be `32`, `s3` will be `91`, and `s4` will be `21`.

- also it is very useful for **swaping**: 

```python

a = 'foo'
b = 'bar'

a, b = b, a
```

# Dictionaries
<a class="anchor" id="dictionary_manipulation"></a>

Dictionaries are Python’s implementation of a data structure that is more generally known as an associative array. A dictionary consists of a collection of key-value pairs. Each key-value pair maps the key to its associated value.

Dictionaries and lists share the following characteristics:

- Both are **mutable**.
- Both are **dynamic**. They can grow and shrink as needed.
- Both can be **nested**. A list can contain another list. A dictionary can contain another dictionary. A dictionary can also contain a list, and vice versa.

Dictionaries differ from lists primarily in how elements are accessed:

- List elements are accessed by their position in the list, via indexing.
- Dictionary elements are accessed via keys.

**Different ways of defining a dictionary**
- Usual ways:
```python
> d = {key1:value1, ke2=value2, ... , keyN=valueN}
> d = dict(key1=value1, key2=value2, ... , keyN=vauleN)
> d = dict([(key1, value1), (key2, value2), ... , (keyN, valueN)])
```
- Creating using empty dictionary:
```python
person={}
person['age']=31
person['job']='student'
person['children'] = ['Ralph', 'Betty', 'Joey']
person['pets'] = {'dog': 'Fido', 'cat': 'Sox'}
```

**regular operations on dictionaries**

`my_dict={'Math': 20, 'Grammer': 17, 'History': 13, 'Art':19 }`
`her_dict={'Math': 18, 'Grammer': 16, 'History': 12, 'Sport':11 }`

| Description| Example | Result |
|:--|:--|:--|
| accessing dictonary values | `my_dict['Math']`| `20`|
| adding a new entry |`my_dict['Sport']=18` | `{'Math': 20, 'Grammer': 17, 'History': 13, 'Art':19, 'Sport':18 }`|
| updating an entry | `my_dict['Sport']=17` | `{'Math': 20, 'Grammer': 17, 'History': 13, 'Art':19, 'Sport':17 }`|
| merging two dict (or) [python3.9 upper] | `my_dict her_dict`| `{'Math': 18, 'Grammer': 16, 'History': 12, 'Art': 19, 'Sport': 11}`|
| merging two dict (or) | `{**my_dict, **her_dict}`| `{'Math': 18, 'Grammer': 16, 'History': 12, 'Art': 19, 'Sport': 11}`|
| deleting an entry | `del my_dict['Sport']` | `{'Math': 20, 'Grammer': 17, 'History': 13, 'Art':19 }`|
| getting all keys | `my_dict.keys()` | `dict_keys(['Math', 'Grammer', 'History', 'Art'])`|
| getting all values | `my_dict.values()` | `dict_values([20, 17, 13, 19])`|
| getting all items | `my_dict.items()` | `dict_items([('Math', 20), ('Grammer', 17), ('History', 13), ('Art', 19)])`|
| getting a value with a default | `my_dict.get('Sport', 0)` | `0`|
| handling missing keys with `.get()` | `my_dict.get('Sport', 0)` | `0`|
| removing all items | `my_dict.clear()` | `{}`|
| updating a dictionary with a dictionary | `my_dict.update(her_dict)` | `{'Math': 18, 'Grammer': 16, 'History': 12, 'Art': 19, 'Sport': 11}`|
| removing a key | `my_dict.pop('Sport')` | `11`|
| removing the last item | `my_dict.popitem()` | `('Art', 19)`|
| Sorting a dictionary by key | `sorted(my_dict.items())` | `[('Art', 19), ('Grammer', 17), ('History', 13), ('Math', 20)]`|


### Notes{#dictionary_notes}
- keys of a dictionary should be hashable. we can try it with using `hash()` function.
- list cannot be a key of a dictionary (because they are not hashable). **tuple** can be dictonary's key. `my_dict={(1,1): 25, (1,2): 35}`


# Sets
<a class="anchor" id="set_manipulation"></a>

In mathematics, a rigorous definition of a set can be abstract and difficult to grasp. Practically though, a set can be thought of simply as a well-defined collection of distinct objects, typically called elements or members.

- Defining sets:

```python
#creat an empty set
s=set()
#create a set with some elements
s={1,2,3}
or
s=set(1,2,3)
#create a set from a list
s=set([1,2,3])
#create a set from a string
s=set('Hello')
```
- when you create a set from a list, it will remove the duplicate elements.

**The set is usually used for searching or finding unique items**. Python’s built-in set type has the following characteristics:

- Sets are **unordered**. 
- **Indexing** is **not** possible in set. However, you can search into set using `in`.
```python
s[1] 
1 in s 
---- ANS -----
TypeError: 'set' object is not subscriptable
True
```
- Set elements are **unique**. Duplicate elements are not allowed (finding unique items in a list, dictionary, or etc). 

```python
s={1,2,3,4,4,4,4} 
s
---- ANS ----- 
{1,2,3,4}
```
- A set itself may be modified, but the elements contained in the set must be of an immutable type.
- set of a string `s='Ali, set(s)'` would be the character of that string `s={'A', 'l' ,'i'}`. 

**Set Operations and Methods**
|Description|Example|Result|
|:--|:--|:--|
|accessing set elements|`for i in s: print(i)`|`A l i`|
|adding an element|`s.add('a')`|`{'A', 'l', 'i', 'a'}`|
|adding multiple elements|`s.update(['a', 'b', 'c'])`|`{'A', 'l', 'i', 'a', 'b', 'c'}`|
|removing an element|`s.remove('a')`|`{'A', 'l', 'i', 'b', 'c'}`|
|removing an element|`s.discard('a')`|`{'A', 'l', 'i', 'b', 'c'}`|
|removing the last element|`s.pop()`|`'A'`|
|removing all elements|`s.clear()`|`set()`|
|union of two sets|`s1|s2`|`{1,2,3} | {3,4,5} = {1,2,3,4,5}`|
|intersection of two sets|`s1&s2`|`{1,2,3} & {3,4,5} = {3}`|
|difference of two sets|`s1-s2`|`{1,2,3} - {3,4,5} = {1,2}`|
|symmetric difference of two sets|`s1^s2`|`{1,2,3} ^ {3,4,5} = {1,2,4,5}`|
|subset|`s1<=s2`|`{1,2} <= {1,2,3}`|
|superset|`s1>=s2`|`{1,2,3} >= {1,2}`|
|disjoint|`s1.isdisjoint(s2)`|`{1,2} isdisjoint {3,4}`|

**Notes**
- Diffrence between `|`, `&`, `-`, `^` opertators and `union()`, `intersection()`, `difference()`, `.symmetric_difference()` methods is that the operators can only tale a single argument, but the methods can take multiple arguments.

### Frozenset{#frozenset}
**frozenset**: is an immutable version of a set. It can be used as a key in a dictionary.
- Frozen sets are mutable, hashable, and ordered.
- Most of the set methods and operators can be used on `frozensets`. `frozensets` **do not** support `add`, `remove`, or `pop` methods.
- The result of operions on `frozensets` is a new `frozensets`, ensuring the immutability of the `frozensets`.
- unique elements are allowed in a `frozensets`.
```python
#creating an empty frozenset
fs=frozenset()
#creating a frozenset from a list
fs=frozenset([1,2,3])
#creating a frozenset from a string
fs=frozenset('Hello')
```

# Packing and Unpacking{#packing_unpacking}
packing and unpacking are two operations that allow you to work with collections of data in Python.
- Packing: is the process of **putting values into a new collection** (like a list or tuple).
- Unpacking: is the process of **extracting values from a collection** and assigning them to variables.

```python
#packing
t = 1, 2, 3
print(t)
#unpacking
a, b, c = t
---- ANS -----
(1, 2, 3)
a=1, b=2, c=3
```
- `*` operator can be used to pack and unpack multiple values.
```python
#packing
t = 1, 2, 3, 4, 5
a, b, *c = t
print(a, b, c)
---- ANS -----
1 2 [3, 4, 5]

#unpacking
a, *b, c = t
print(a, b, c)
---- ANS -----
1 [2, 3, 4] 5
```

- `**` operator can be used to pack and unpack multiple values. This operator is useful for dictionaries.
```python
# Two dictionaries representing two different students' grades
student_grades_1 = {'Math': 90, 'English': 92}
student_grades_2 = {'Science': 88, 'History': 94}
# Merging both dictionaries into a new one
combined_grades = {**student_grades_1, **student_grades_2}
print(combined_grades)
---- ANS -----
{'Math': 90, 'English': 92, 'Science': 88, 'History': 94}
```
- unpacking keys and values of a dictionary
```python
# Unpacking keys and values of a dictionary
student_grades = {'Math': 90, 'English': 92, 'Science': 88, 'History': 94}
#unpacking only keys 
course_names = [*student_grades]
#unpacking both keys and values
subjects, grades = zip(*student_grades.items())
print(subjects)
print(grades)
---- ANS -----
('Math', 'English', 'Science', 'History')
(90, 92, 88, 94)
```

