<a class="anchor" id="functions_in_python"></a>
## Functions in Python
You may be familiar with the mathematical concept of a **function**. A function is a relationship or mapping between one or more inputs and a set of outputs. In fact, appropriate function definition and use is so critical to proper software development that virtually all modern programming languages support both built-in and user-defined functions.

Some built-in python examples: 
- `id()`: takes one argument and returns that object’s unique integer identifier
- `len()`: returns the length of the argument passed to it
- `any`: takes an iterable as its argument and returns `True` if any of the items in the iterable are truthy and `False` otherwise

Each of these built-in functions performs a specific task. The code that accomplishes the task is defined somewhere, but you don’t need to know where or even how the code works. All you need to know about is the function’s interface:

1. What **arguments** (if any) it takes
2. What **values** (if any) it returns

Why functions are good: 
1) Abstraction and Reusability
2) Modularity
3) Namespace Separation


## Function Calls and Definition {#function_calls_and_definition}
The usual syntax for defining a Python function is as follows:

```python
def <function_name>([<parameters>]):
    <statement(s)>
```
The components of the definition are explained in the table below:

| Component | Meaning |
|:--|:--|
| `def` | The keyword that informs Python that a function is being defined
| `<function_name>` | A valid Python identifier that names the function
| `<parameters>` | An optional, comma-separated list of parameters that may be passed to the function
| `:`	| Punctuation that denotes the end of the Python function header (the name and parameter list)
| `<statement(s)>` | A block of valid Python statements (body of the function)
|`<arguments>`</arguments>| The values passed into the function. They correspond to the `<parameters>` in the Python function definition.

The syntax for calling a Python function is as follows:

```python
<function_name>([<arguments>])
```
- `<arguments>` are the values passed into the function. They correspond to the `<parameters>` in the Python function definition.

- `stub` function: Occasionally, you may want to define an empty function that does nothing. This is referred to as a **stub**, which is usually a temporary placeholder for a Python function that will be fully implemented at a later time. Just as a block in a control structure can’t be empty, neither can the body of a function. To define a stub function, use the `pass` statement:

```python
def f():
    pass
```
### Argument passing{#argument_passing}
When you call a Python function, you can pass arguments to the function in a number of ways. The most common ways are **positional arguments** and **keyword arguments**.

1) **Positional Arguments**: The most straightforward way to pass arguments to a Python function is with **positional arguments** (also called **required arguments**). In the function definition, you specify a comma-separated list of parameters inside the parentheses:

```python
# formal parameters
# function definition
def f(qty, item, price):
    print(f'{qty} {item} cost ${price:.2f}')
    
# actual parameters
# function call
x = 25
f(6, 'bananas', x)
```
Common **errors** in positional arguments: 
- Too few arguments: `f(6, 'bananas')`
- Too many arguments: `f(6, 'bananas', 1.74, 'kumquats')`

2) **Keyword Arguments**: When you’re calling a function, you can specify arguments in the form ‍`<keyword>=<value>‍`. In that case, each `<keyword>` must match a parameter in the Python function definition. For example, the previously defined function `f()` may be called with keyword arguments as follows:
    ```python
    f(qty=6, item='bananas', price=1.74)
    ```
- we use this kind of functions when the arguments are high.
- You can call a function using both positional and keyword arguments (all the positional arguments must come first, before any keyword arguments)

    ```python
    f(6, 'bananas', price=1.74)
    ```
3) **Default Parameters**: If a parameter specified in a Python function definition has the form `<name>=<value>`, then `<value>` becomes a default value for that parameter. Parameters defined this way are referred to as **default or optional parameters**. An example of a function definition with default parameters is shown below:
    ```python 
    def f(qty=6, item='bananas', price=1.74):
        print(f'{qty} {item} cost ${price:.2f}')
    ```
- You can override default values by providing additional positional arguments in the order they appear in the function definition.
- In Python, **default parameter values** are **defined only once** when the function is defined (that is, when the def statement is executed). The default value isn’t re-defined each time the function is called. Thus, each time you call `f()` without a parameter, you’re performing `.append()` on the same list. So, in order to solve this, we should do as follows:
    ```python
    def f(my_list=None):
        if my_list is None:
            my_list = []
        my_list.append('###')
        return my_list
    ```

> **Note:** 
> - Using positional arguments for required parameters that have a clear and logical ordering 
> - Using keyword arguments to enhance clarity when a function has multiple parameters or when the purpose of arguments might not be immediately clear from the context alone.
> - Using default parameters to provide sensible defaults for optional parameters.

#### Pass-By-Value and Pass-By-Reference 

- **Pass-by-value:** A copy of the argument is passed to the function.
- **Pass-by-reference:** A reference to the argument is passed to the function.

Are parameters in Python pass-by-value or pass-by-reference? The answer is they’re neither, exactly. That’s because a reference doesn’t mean quite the same thing in Python as it does in Pascal.

Recall that in Python, every piece of data is an **object**. A reference points to an object, not a specific memory location. That means assignment isn’t interpreted the same way in Python as it is in a programming language such as Pascal. Let's see what happen in Python: 
```python
x = 5
x = 10
```
These assignment statements have the following meaning:

- **The first statement** causes `x` to point to an object whose value is `5`.
- **The next statement** reassigns `x` as a new reference to a different object whose value is `10`. Stated another way, the second assignment rebinds `x` to a different object with value `10`.

In Python, when you pass an argument to a function, a similar **rebinding** occurs. Consider this example:
```python
def f(fx):
    print('fx =', fx, '/ id(fx) = ', id(fx))#for checking what is happening
    fx = 10
    print('fx =', fx, '/ id(fx) = ', id(fx))#for checking what is happening
    
x = 5
f(x)
print(x)
------ ANS ------
`x` would be `5` and `f(x)` would be `None`
```


Argument passing in Python is somewhat of a hybrid between pass-by-value and pass-by-reference. What gets passed to the function is a reference to an object, but the reference is passed by value.

> **Note:** Python’s argument-passing mechanism has been called **pass-by-assignment**. This is because parameter names are bound to objects on function entry in Python, and assignment is also the process of binding a name to an object. You may also see the terms pass-by-object, pass-by-object-reference, or pass-by-sharing.

Argument passing in Python can be summarized as follows. 
- **Passing an immutable object**, like an `int`, `str`, `tuple`, or `frozenset`, to a Python function acts like pass-by-value. The function can’t modify the object in the calling environment.
- **Passing a mutable object** such as a `list`, `dict`, or `set` acts somewhat—but not exactly—like pass-by-reference. The function can’t reassign the object wholesale, but it can change items in place within the object, and these changes will be reflected in the calling environment.

### Return Statement
A Python function can return a value to the calling environment using the `return` statement. The syntax for a `return` statement is as follows:
```python
return [<expression>]
```

The `<expression>` can be a single value, multiple values separated by commas, or no value at all.
  -  A function can return any type of **object**. In Python, that means pretty much anything whatsoever. In the calling environment, the function call can be used syntactically in any way that makes sense for the type of object the function returns.
  - If multiple comma-separated expressions are specified in a `return` statement, then they’re packed and returned as a `tuple`
  - When no return value is given, a Python function returns the special Python value `None`. The same thing happens if the function body doesn’t contain a `return` statement at all and the function falls off the end

A `return` statement in a Python function serves two purposes:

1. It immediately terminates the function and passes execution control back to the caller.
2. It provides a mechanism by which the function can pass data back to the caller.

- This sort of paradigm can be useful for **error checking** in a function. You can check several error conditions at the start of the function, with `return` statements that bail out if there’s a problem:

```python
def f():
    if error_cond1:
        return
    if error_cond2:
        return
    if error_cond3:
        return

    <normal processing>
```

- **Control Flow** is other options that can be used with `return` statement. For example, you can use `return` to exit a loop early, or to return a value from a loop. Here’s an example that uses `return` to exit a loop early:

```python
def f():
    for i in range(10):
        if i == 5:
            return
        print(i)
```

<a class="anchor" id="variable-length_argument_lists"></a>
## Variable-Length Argument Lists
In some cases, when you’re defining a function, you may not know beforehand how many arguments you’ll want it to take. Suppose, for example, that you want to write a Python function that computes the average of several values.
- one sultion is using list or tuple to pass the arguments. However, the drawback is that the added step of having to group the values into a list or tuple is probably not something the user of the function would expect, and it isn’t very elegant. Whenever you find Python code that looks inelegant, there’s probably a better option. 
- The BEST solution is use **Argument Tuple Packing**

### Argument Tuple Packing{#argument_tuple_packing}
When a parameter name in a Python function definition is preceded by an asterisk (`*`), it indicates **argument tuple packing**. Any corresponding arguments in the function call are packed into a tuple that the function can refer to by the given parameter name. Here’s an example:

```python
def f(*args):
    print(args)
    print(type(args), len(args))
    for x in args:
        print(x)
        
f(1, 2, 3)
----- Answer -----
(1, 2, 3)
<class 'tuple'> 3
1
2
3
```
### Argument Tuple Unpacking 
An analogous operation is available on the other side of the equation in a Python function call. When an argument in a function call is preceded by an asterisk (`*`), it indicates that the argument is a tuple that should be **unpacked** and passed to the function as separate values:

```python
def f(x, y, z):
    print(f'x = {x}')
    print(f'y = {y}')
    print(f'z = {z}')
    
f(1, 2, 3)
----- Answer -----
x = 1
y = 2
z = 3
------------------

t = ('foo', 'bar', 'baz')
f(*t)

----- Answer -----
x = foo
y = bar
z = baz
------------------

```

> **Note** Although this type of unpacking is called **tuple** unpacking, it doesn’t only work with tuples. The asterisk (`*`) operator can be applied to any iterable in a Python function call. For example, a list or set can be unpacked as well:
### Argument Dictionary packing/unpacking 
Python has a similar operator, the double asterisk (`**`), which can be used with Python function parameters and arguments to specify **dictionary packing and unpacking**. Preceding a parameter in a Python function definition by a double asterisk (`**`) indicates that the corresponding arguments, which are expected to be `key=value` pairs, should be packed into a dictionary:

```python
def f(**kwargs):
    print(kwargs)
    print(type(kwargs))
    for key, val in kwargs.items():
        print(key, '->', val)
        
f(foo=1, bar=2, baz=3)
----- Answer -----
{'foo': 1, 'bar': 2, 'baz': 3}
<class 'dict'>
foo -> 1
bar -> 2
baz -> 3
------------------
```
In this case, the arguments `foo=1`, `bar=2`, and `baz=3` are packed into a dictionary that the function can reference by the name `kwargs`. Again, any name can be used, but the peculiar `kwargs` (which is short for **keyword args**) is nearly standard. You don’t have to adhere to it, but if you do, then anyone familiar with Python coding conventions will know straightaway what you mean.

**Argument dictionary unpacking** is analogous to argument tuple unpacking. When the double asterisk (`**`) precedes an argument in a Python function call, it specifies that the argument is a dictionary that should be unpacked, with the resulting items passed to the function as keyword arguments:

```python
def f(a, b, c):
    print(F'a = {a}')
    print(F'b = {b}')
    print(F'c = {c}')
        
d = {'a': 'foo', 'b': 25, 'c': 'qux'}
f(**d)
----- Answer -----
a = foo
b = 25
c = qux
------------------
```
The items in the dictionary `d` are unpacked and passed to `f()` as keyword arguments. So, `f(**d)` is equivalent to `f(a='foo', b=25, c='qux')`

### Putting it All Together
Think of `*args` as a variable-length positional argument list, and `**kwargs` as a variable-length keyword argument list.
All three—standard positional parameters, `*args`, and `**kwargs`—can be used in one Python function definition. If so, then they should be specified in that order:
```python
def f(a, b, *args, **kwargs):
    print(F'a = {a}')
    print(F'b = {b}')
    print(F'args = {args}')
    print(F'kwargs = {kwargs}')
        
f(1, 2, 'foo', 'bar', 'baz', 'qux', x=100, y=200, z=300)
----- Answer -----
a = 1
b = 2
args = ('foo', 'bar', 'baz', 'qux')
kwargs = {'x': 100, 'y': 200, 'z': 300}
------------------
```

### Multiple Unpackings in a Python Function Call
Python `version 3.5` introduced support for additional unpacking generalizations, as outlined in [PEP 448](https://www.python.org/dev/peps/pep-0448). One thing these enhancements allow is **multiple unpackings** in a single Python function call:

```python
def f(*args):
    for i in args:
        print(i)
        
a = [1, 2, 3]
t = (4, 5, 6)
s = {7, 8, 9}
f(*a, *t, *s)
----- Answer -----
1
2
3
4
5
6
8
9
7
------------------
```
Multiple dictionary unpacking example: 
```python
def f(**kwargs):
    for k, v in kwargs.items():
        print(k, '->', v)
f(**{'a': 1, 'b': 2}, **{'x': 3, 'y': 4})
----- Answer -----
a -> 1
b -> 2
x -> 3
y -> 4
------------------
```

### Keywords-Only Arguments
A Python function in `version 3.x` can be defined so that it takes **keyword-only arguments**. These are function arguments that must be specified by keyword. Let’s explore a situation where this might be beneficial.
Suppose you want to write a Python function that takes a variable number of string arguments, concatenates them together separated by a dot (`"."`), and prints them to the console.
```python
def concat(*args, prefix='-> '):
    print(f'{prefix}{".".join(args)}')
```
In the above example, `prefix` becomes a keyword-only parameter. Its value will never be filled by a positional argument. It can only be specified by a named keyword argument:
```python
concat('a', 'b', 'c', prefix='... ')
concat('a', 'b', 'c', prefix='--> ')
----- Answer -----
... a.b.c
--> a.b.c
------------------
```


Keyword-only arguments allow a Python function to take a variable number of arguments, followed by one or more additional **options** as keyword arguments. If you wanted to modify `concat()` so that the separator character can optionally be specified as well, then you could add an additional keyword-only argument:
```python
def concat(*args, prefix='-> ', sep='.'):
    print(f'{prefix}{sep.join(args)}')
    
concat('a', 'b', 'c')
----- Answer -----
--> a.b.c
------------------
```
If a keyword-only parameter is given a default value in the function definition (as it is in the example above), and the keyword is omitted when the function is called, then the default value is supplied.

What if you want to define a Python function that takes a keyword-only argument but doesn’t take a variable number of positional arguments? For example, the following function performs the specified operation on two numerical arguments:

```python
def oper(x, y, *, op='+'):
    if op == '+':
        return x + y
    elif op == '-':
        return x - y
    elif op == '/':
        return x / y
    else:
        return None

oper(3, 4, op='+')
oper(3, 4, op='/')
----- Answer -----
7
0.75
------------------
```

Python version 3 allows a **variable argument parameter** in a Python function definition to be just a bare asterisk (`*`), with the name omitted:

### Positional-Only Arguments
As of Python 3.8, function parameters can also be declared **positional-only**, meaning the corresponding arguments must be supplied positionally and can’t be specified by keyword.
To designate some parameters as positional-only, you specify a bare slash (`/`) in the parameter list of a function definition. Any parameters to the left of the slash (`/`) must be specified positionally. For example, in the following function definition, `x` and `y` are positional-only parameters, but `z` may be specified by keyword:

```python
# This is Python 3.8
def f(x, y, /, z):
    print(f'x: {x}')
    print(f'y: {y}')
    print(f'z: {z}')

f(1, 2, 3)
print('--next--')
f(1, 2, z=3)
print('--next--')
f(x=1, y=2, z=3)
----- Answer -----
x: 1
y: 2
z: 3
--next--
x: 1
y: 2
z: 3
--next--
TypeError: f() got some positional-only arguments passed as keyword arguments: 'x, y'
------------------
```

- The positional-only and keyword-only designators may both be used in the same function definition:

```python
# This is Python 3.8
def f(x, y, /, z, w, *, a, b):
    print(x, y, z, w, a, b)
    
f(1, 2, z=3, w=4, a=5, b=6)
f(1, 2, 3, w=4, a=5, b=6)
----- Answer -----
f(1, 2, z=3, w=4, a=5, b=6)
------------------
In this example:

- `x` **and** `y` are positional-only.
- `a` **and** `b` are keyword-only.
- `z` **and** `w` may be specified positionally or by keyword.
```
## Docstring {#docstring}
When the first statement in the body of a Python function is a string literal, it’s known as the function’s **docstring**. A docstring is used to supply documentation for a function. It may consist of the following information: 
- Brief Description: A brief description of the function’s purpose
- Parameters: A description of the function’s parameters, including the name, type and a short description of each.
- Return Value: A description of the value and the type of the function’s return value.
- Other Sections
  - Example Usage: Examples of how to use the function
  - Raises: Detail any exceptions that the function may raise
  - Notes: Any additional information that may be useful to the user
  - See Also: Links to related functions or resources
The following is an example of a function definition with a docstring:
```python
def calculate_area(radius):
    """
    Calculate the area of a circle given its radius.

    Args:
        radius (float): The radius of the circle.

    Returns:
        float: The area of the circle.

    Raises:
        ValueError: If the radius is negative.

    Examples:
        >>> calculate_area(5)
        78.53981633974483

    Note:
        The area is calculated using the formula pi * radius^2.
    """
    if radius < 0:
        raise ValueError("The radius cannot be negative.")
    return 3.141592653589793 * radius ** 2
```

**Multi-line docstrings** are used for lengthier documentation. A multi-line docstring should consist of a summary line, followed by a blank line, followed by a more detailed description. The closing quotes should be on a line by themselves:
```python
def foo(bar=0, baz=1):
    """Perform a foo transformation.

    Keyword arguments:
    bar -- magnitude along the bar axis (default=0)
    baz -- magnitude along the baz axis (default=1)
    """
    # <function_body>
```
Docstring formatting and semantic conventions are detailed in [PEP 257](https://www.python.org/dev/peps/pep-0257). But here are some important ones: 
- Google Style: This is the most popular style of docstrings. It is used by Google and many other Python projects. It is also the style used by the Sphinx documentation generator.
- Numpy/Scipy Style: This style is used by the NumPy and SciPy projects. It is similar to the Google style but with a few differences.
- reStructuredText (reST): This style is used by the Python standard library. It is also the style used by the Sphinx documentation generator.
- Epytext: This style is used by the Epydoc documentation generator.

Here are the ways to **access** docstring of each function in python:
1. You can access a function’s docstring with the expression `<function_name>.__doc__`.
2. In the interactive Python interpreter, you can type `help(<function_name>)` to display the docstring for `<function_name>`
3. In interactive Python interpreter like Jupyter Notebook, you can type `<function_name>?` to display the docstring for `<function_name>`


### Annotations 
As of version 3.0, Python provides an additional feature for documenting a function called a **function annotation**. Annotations provide a way to attach metadata to a function’s parameters and return value.
```python
def f(a: float, b: float = 8) -> int:
    """Add two number.

    :param a: First input
    :param b: Second input
    :return: Sum of two numbers.
    """
    
    return a + b
```
To add an annotation to a Python function parameter, insert a colon (`:`) followed by any expression after the parameter name in the function definition. To add an annotation to the return value, add the characters `->` and any expression between the closing parenthesis of the parameter list and the colon that terminates the function header. Here’s an example:

```python
def f(a: '<a>', b: '<b>') -> '<ret_value>':
    pass
```
The annotation for parameter `a` is the string `'<a>'`, for `b` the string `'<b>'`, and for the function return value the string `'<ret_value>'`.

```python
f.__annotations__
f.__annotations__['a']
----- Answer -----
{'a': int, 'b': int, 'return': int}
int
------------------
```

An annotation can even be a composite object like a list or a dictionary, so it’s possible to attach multiple items of metadata to the parameters and return value:

```python
def area(
    r: {
           'desc': 'radius of circle',
           'type': float
       }) -> \
       {
           'desc': 'area of circle',
           'type': float
       }:
    return 3.14159 * (r ** 2)

area.__annotations__['r']['desc']
area.__annotations__['return']['type']
----- Answer -----
'radius of circle'
float
------------------
```

## Lambda Functions
Lambda functions are a feature in Python that allows you to create small, one-time, anonymous function objects. They are most useful when you need a function for a short period, small tranformations or actions, or when passing a function as an argument to another function like `sort()`, `map()`, `filter()`, or `reduce()`.
Lambda functions differ from regular functions in several ways:
1. **Syntax:** Lambda functions are written using the `lambda` keyword rather than `def`. They also follow a more compact syntax, typically fitting on a single line.
   ```python
   #Lambda Function Expression
    lambda <arguments>: <expression>
    #regular function
   def add(x, y):
       return x + y
    #lambda function
   add_lambda = lambda x, y: x + y
   ```
2. **Anonymity:** Lambda functions are anonymous; they don't need a name. However, they can be assigned to a variable as shown above.
3. **Expression Limit:** Lambda functions are limited to a single expression and cannot include statements or annotations. This contrasts with regular functions, which can consist of multiple expressions and statements.
   ```python
   # Regular function with multiple statements
    def is_even(number):
        if number % 2 == 0:
            return True
        else:
            return False
    # Lambda function with a single expression
    is_even_lambda = lambda number: number % 2 == 0 
   ```
4. **Use Case:** Regular functions are more versatile due to their ability to contain multiple statements and are typically used for complex tasks. Lambda functions excel in simplifying code, especially when used for simple, one-off operations.
5. **Return Behavior:** Lambda functions automatically return the result of their single expression without the need for a `return` statement, unlike regular functions that require an explicit return.

Here are some examples with `map()` and `filter()` functions:
```python
# Map function's example
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)
# Filter function's example
even = list(filter(lambda x: x % 2 == 0, numbers))
print(even)
----- ANS -----
[1, 4, 9, 16, 25]
[2, 4]
------------------
```
### Iteration Functions{#iteration_functions}
When working with iterable objects like lists, tuples, and dictionaries, Python provides several functions to facilitate iteration and data manipulation.

Some of these iteration functions are:
- `range()`: Generates a sequence of numbers, which is often used in for-loops for iteration.
- `sorted()`: Returns a new sorted list from the elements of any iterable.
- `filter()`: Constructs an iterator from elements of an iterable for which a function returns true.
- `map()`: Applies a given function to each item of an iterable and returns a list of the results.
- `zip()`: Combines elements from multiple iterables into tuples.

Here are some examples of these functions:
```python
# Range function's example
for i in range(5):
    print(i, end=' ')
print() 
# Sorted function's example
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
sorted_numbers = sorted(numbers)
print(sorted_numbers)
# Filter function's example
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)
# Map function's example
squared_numbers = list(map(lambda x: x ** 2, numbers))
print(squared_numbers)
# Zip function's example
names = ['Alice', 'Bob', 'Charlie']
ages = [24, 50, 18]
zipped = list(zip(names, ages))
print(zipped)
----- ANS -----
0 1 2 3 4 
[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
[4, 2, 6]
[9, 1, 16, 1, 25, 81, 4, 36, 25, 9, 25]
[('Alice', 24), ('Bob', 50), ('Charlie', 18)]
------------------
```