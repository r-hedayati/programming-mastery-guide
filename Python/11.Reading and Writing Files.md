# Files Handling{#files-handling}
Files are named locations on disk to store related information. They are used to permanently store data in a non-volatile memory (e.g. hard disk). Since Random Access Memory (RAM) is volatile (which loses its data when the computer is turned off), we use files for future use of the data. When we want to read from or write to a file, we need to open it first. When we are done, it needs to be closed so that resources that are tied with the file are freed. Hence, in Python, a file operation takes place in the following order:

1. Open a file
2. Read or write (perform operation)
3. Close the file

Files are typically opened in text (readable by humans) or binary (readable by computers) mode.
- Text Files Formats: `.txt`, `.csv`, `.json`, `.html` , `.py`
- Binary Files Formats: `.jpg`, `.mp3`, `.mp4`, `.doc`, `.exe`

> **Note:** Binary files are typically more efficient for storing complex data because they use all available byte values, which allows for a more compact representation of the content.


Files on most modern file systems are composed of three main parts:

- **Header**: metadata about the contents of the file (file name, size, type, and so on)
- **Data**: contents of the file as written by the creator or editor
- **End of file (EOF)**: special character that indicates the end of the file

## File Paths{#file-paths}
When you access a file on an operating system, a file path is required. The file path is a string that represents the location of a file. It’s broken up into three major parts:

1. **Folder Path:** the file folder location on the file system where subsequent folders are separated by a forward slash `/` (Unix) or backslash `\` (Windows)
2. **File Name:** the actual name of the file
3. **Extension:** the end of the file path pre-pended with a period (`.`) used to indicate the file type

There are two types of file paths that you'll commonly work with:

- **Absolute File Paths:** An absolute path is the full address of a file or a folder, starting from the root of the filesystem all the way to the target file or directory. It is independent of the current working directory, which means it doesn't change no matter where your script is running from.
- **Relative File Paths:** In contrast, a relative path describes the location of a file relative to the current working directory of the script. It's often shorter and more convenient when your files are organized in a known structure

Given the differences between operating systems in how file paths are structured (like the use of different directory separators), Python provides tools to handle file paths in a way that works consistently across Windows, macOS, and Linux. 

The `os` module in Python provides many functions for interacting with the operating system. One of the most useful functions is `os.path.join()`, which joins one or more path components intelligently. This function will automatically choose the correct separator for the specific operating system.

```python
import os

file_path = os.path.join('folder', 'subfolder', 'example.txt')
print(file_path)  # Outputs a path that is appropriate for the OS
```

## Line Ending and Encoding{#line-ending-and-encoding}
- Note that each line ended with `\n` in Unix or Mac, and with `\r\n` in Windows. 
- An encoding is a translation from byte data to human readable characters. This is typically done by assigning a numerical value to represent a character. The two most common encodings are the [ASCII](https://www.ascii-code.com/) and [UNICODE](https://unicode.org/) Formats.
- ASCII (store 128 characters) is actually a subset of [Unicode (stores 1,114,112 characters)](https://realpython.com/python-encodings-guide/) (UTF-8), meaning that ASCII and Unicode share the same numerical to character values.

## Opening/Reading/Writing/Closing a File in Python{#opening-and-closing-a-file-in-python}

1. **Opening Files**
   The `open()` function is the key to file handling in Python. It allows you to open a file and returns a file object, which then can be used to read from or write to the file. The syntax is as follows
    ```python
    file_obj = open(<file_path>, <mode>)
    ```
    - `file_path` is a string representing the file path
    - `mode` is a string representing the file mode, which determines in what mode the file is opened. The most common values are:
        - `'r'`: open for reading (default)
        - `'w'`: open for writing, truncating the file first
        - `'a'`: open for writing, appending to the end of the file if it exists
        - `'rb'` or `'wb'`: open in binary mode (read/write using byte data)
2. **Reading Files**
   Once a file is opened in read mode (`r`), you can read its contents using methods like:
   - `read(size)`: Reads and returns the file's content up to size bytes or characters. If size is omitted or negative, the entire content of the file will be read.
   - `readline()`: Reads and returns one line from the file.
   - `readlines()`: Reads and returns a list of lines from the file.
  
3. **Writing Files**
   To write to a file, you first open it in write (`w`) or append (`a`) mode. Then you can use the following methods:
   - `write(string)`: Writes the string to the file.
   - `writelines(list_of_strings)`: Writes a list of strings to the file.
    > Note that opening a file in write mode will create a new file if it does not exist or truncate it (make it empty) if it does
4. Closing Files
   When you’re done with a file, it’s important to close it using the `close()` method. This ensures that the resources tied to the file are freed. You can also use the `with` statement to automatically close the file once you’re done with it.
   ```python
    #option 1
    file_obj.close()
    #option 2
    with open(<file_path>, <mode>) as file_obj:
         # Perform file operations
    ```
    The `with` statement automatically takes care of closing the file once it leaves the block, even in cases of error.

The `open()` function has didferent options for modes, which are [fully documented online](https://docs.python.org/3/library/functions.html#open), but the most commonly used ones are the following:

|Character | Meaning|
|:--|:--|
|`'r'` | Open for reading (default). If the file does not exist, it raises an `IOError`|
|`'w'` | Open for writing, if the file exists, it will be overwritten. If not, it will be created|
|`'a'` | Open for writing, appending to the end of the file if it exists. If not, it will be created|
| `'r+'` | Open for reading and writing (`IOError` if not exists)|
| `'w+'` | Open for writing and reading (overwriting existing file)|
| `'a+'` | Open for reading and writing (appending if file exists)|
|`'rb'` or `'wb'` | Open in binary mode (read/write using byte data)|


## Useful Methods for Reading/Writing Files{#useful-methods-for-reading-files}


|Method |What It Does|
|:--|:--|
|`.read(size=-1)` | This reads from the file based on the number of `size` bytes. If no argument is passed or `None` or `-1` is passed, then the entire file is read. |
|`.readline(size=-1)` | This reads at most size number of characters from the line. This continues to the end of the line and then wraps back around. If no argument is passed or `None` or `-1` is passed, then the entire line (or rest of the line) is read. |
|`.readlines()` | This reads the remaining lines from the file object and returns them as a list. |
|`.write(string)`	|This writes the string to the file.|
|`.writelines(seq)`	|This writes the sequence to the file. No line endings are appended to each sequence item. It’s up to you to add the appropriate line ending(s).|



### Iterating over each line in the file
Iterating over a file object line by line is memory efficient because it reads one line at a time, processes it, and then discards it before moving on to the next line.

This method is also time-efficient, as it starts processing the file immediately without waiting for the entire file to be read. It is especially beneficial when you are searching for specific information or when only a part of the file is relevant to your task.

In contrast, methods like `read()` or `readlines()` that read the entire file content at once can lead to high memory usage, which might be impractical for large files and could potentially slow down your program or even cause it to crash if the system runs out of memory.

```python

### first solution 

with open('myfile.txt', 'r') as reader:
    # Read and print the entire file line by line
    line = reader.readline()
    while line != '':  # The EOF char is an empty string
        print(line, end='')
        line = reader.readline()
        
### second solution
with open('myfile.txt', 'r') as reader:
    for line in reader.readlines():
        print(line, end='')
        
### simplify the second solution 
with open('myfile.txt', 'r') as reader:
    # Read and print the entire file line by line
    for line in reader:
        print(line, end='')
```

This final approach is more Pythonic and can be quicker and more memory efficient. Therefore, it is suggested you use this instead.

### `write()` vs `writelines()`
The main difference between the `write()` and `writelines()` methods is their intended use case. `write()` is meant for writing a single string at a time, whereas `writelines()` is optimized for writing a series of strings in one go.
```python
with open('myfile.txt', 'w') as writer:
    writer.write('this is line 1\n')
    writer.write('this is line 2\n')
    writer.write('this is line 3\n')
```
```python
with open('myfile.txt', 'w') as writer:
    lines = ['this is line 1\n', 'this is line 2\n', 'this is line 3\n']
    writer.writelines(lines)
```
- Line Endings: The `write()` method will write exactly what you tell it to, including line endings. The `writelines()` method, on the other hand, does not add any separators or line endings between the strings it writes; you must include them yourself at the end of each string if desired.
- Performance: When you have **a large** number of strings to write to a file, `writelines()` might offer **better performance** because it is designed to handle multiple strings in one method call, reducing the overhead of multiple write() calls
- Convenience:  If your data is already in the form of an iterable of strings (like a list or a generator), `writelines()` can be more straightforward to use than a loop with write() calls.

In summary, use `write()` when dealing with individual strings and `writelines()` when you have a collection of strings that you want to write to a file efficiently.
### Appending to a File 
    
```python
with open('myfile.txt', 'a') as a_writer:
    a_writer.write('this is line 7')
```
### Potential Risks of Overwriting Files
When you open a file in write mode (`'w'`), Python will create a new file if it does not exist or overwrite the file if it does. This can be risky, especially if you accidentally overwrite a file that contains important data. To avoid this:
- Consider checking if the file exists before opening it in write mode. You can do this using the `os.path.exists()` function from the `os` module

```python
import os
# Check if the file exists before opening it in write mode
if not os.path.exists('files/important.txt'):
    with open('files/important.txt', 'w') as file:
        file.write("This is important data.")
else:
    print("File already exists. Aborting to prevent data loss.")
```

### Working with two files at the same time

```python
d_path = 'myfile.txt'
d_r_path = 'myfile_reversed.txt'
with open(d_path, 'r') as reader, open(d_r_path, 'w') as writer:
    dog_breeds = reader.readlines()
    writer.writelines(reversed(dog_breeds))
```

## File Buffering and Flushing{#file-buffering-and-flushing}
File buffering is a mechanism that allows a file to store data temporarily before writing it to the disk. This can improve performance by reducing the number of times data is written to the disk. When you write to a file, the data is first stored in a buffer, and then, when the buffer is full or when the file is closed, the data is written to the disk.


Python's file objects are line-buffered (if the file is opened in text mode and connected to a terminal) or block-buffered (if the file is not connected to a terminal). The buffer size can be controlled by the `buffering` parameter in the `open()` function:

- A `buffering` value of `0` turns off buffering, meaning each `write()` will directly affect the file.
- A `buffering` value of `1` enables line buffering, writing data to the file whenever a newline is encountered.
- A `buffering` value greater than `1` sets the buffer size to that number of bytes.

```python
# Open a file with a specific buffer size
file = open('files/buffered.txt', 'w', buffering=1024)
file.write("This data is buffered.")
file.write('\n')
```
In the above example, the data may reside in the buffer and not be immediately written to `buffered.txt`. The write to disk will only occur when the buffer is **full** or when the file is **closed**.

There are situations where you may want to ensure that all buffered data is written to disk immediately. For example, in the case of a program crash or if you need to generate real-time output that another process is watching.
To manually flush the buffer and write data to disk, you can use the `flush()` method:
```python
file.write("This data might be buffered.")
# Ensure that data is written to disk
file.flush()
```

After calling `flush()`, you can be confident that all the data written up to that point has been physically written to disk.

Another common scenario where you might want to flush the buffer is when dealing with user prompts. If you're writing a prompt to the screen and awaiting user input, you'll want to flush the output so that the prompt actually appears before the program pauses for input.

Keep in mind that calling `flush()` too frequently can degrade performance since it negates the benefits of buffering by increasing the number of write operations. Use it judiciously when immediate writing of data is necessary.

In summary, while Python handles buffering efficiently in the background, knowing when to use `flush()` gives you additional control over when your data gets persisted to disk, which can be crucial for data integrity and program behavior.

## Practical Examples{#practical-examples}

- **Example 1: Writing Log Data to a File**
  ```python
    import datetime
    # Function to log messages
    def log_message(log_file, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(log_file, 'a') as file:
            file.write(f"[{timestamp}] {message}\n")

    # Log some messages
    log_message("files/app.log", "Application start")
    log_message("files/app.log", "An important event occurred")
    log_message("files/app.log", "Application end")
  ```
  In this example, we define a log_message function that writes a message to a specified log file. Each message is prefixed with a timestamp. The log file is opened in append mode so that each message is added to the end without overwriting previous log entries

- **Example 2: Generating and Saving a Report**
  ```python
    # Data to include in the report
    report_data = {
        'Title': 'Sales Report for March 2023',
        'Total Sales': '9500',
        'Top Product': 'Gadget Pro',
        'Customer Satisfaction': '89%'
    }

    # Function to generate a report
    def generate_report(report_file, data):
        with open(report_file, 'w') as file:
            file.write(f"{data['Title']}\n")
            file.write("=" * len(data['Title']) + "\n")
            for key, value in data.items():
                if key != 'Title':
                    file.write(f"{key}: {value}\n")

    # Generate and save the report
    generate_report("files/monthly_sales_report.txt", report_data)
  ```
  In this example, we create a dictionary holding the data for our report. We then define a `generate_report` function that takes a filename and the report data as arguments. The report is written to the specified file, with the title underlined for emphasis. The file is opened in write mode (`'w'`), meaning that each time we generate a report, we start with a fresh file.