
## PolyMorphism{#polymorphism}
Polymorphism is the ability to use the same syntax for objects of different types: 

```python   
class Animal:
    def __init__(self, name):    # Constructor of the class
        self.name = name
    def talk(self):              # Abstract method, defined by convention only
        pass                      # Inherited classes will override this method

class Cat(Animal):
    def talk(self):
        return 'Meow!'

class Dog(Animal):
    def talk(self):
        return 'Woof! Woof!'

animals = [Cat('Missy'),
           Cat('Mr. Mistoffelees'),
           Dog('Lassie')]
for animal in animals:
    print(animal.name + ': ' + animal.talk())
```
In the above example, the `talk()` method of the `Animal` class is overridden in the `Cat` and `Dog` classes. The `talk()` method of the `Animal` class is called an abstract method because it is not implemented in the `Animal` class. It is only intended to be implemented in subclasses.

> Polymorphism through inheritance is not just a tool for overriding methods; it is also a cornerstone in many design patterns. It allows for the design of flexible interfaces and the implementation of behaviors that can vary at runtime, depending on the object's class. Design patterns like the Strategy pattern, Factory pattern, and Observer pattern heavily rely on polymorphism to achieve their flexible and dynamic nature.

### Duck Typing{#duck-typing}
Duck typing is a concept related to polymorphism. It is often expressed as “If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.” This means that Python will allow you to use an object if it supports the methods and behaviors you need, regardless of its actual type.

### Dynamic Typing and Polymorphic Behavior{#dynamic-typing}
Python is dynamically typed, which means that you can change the type of an object after you have created it. This allows for polymorphic behavior. For example, you can create a list and then assign a string to the same variable:

```python   
a = [1, 2, 3]
print(a)
a = 'hello'
print(a)
```
In the above example, the variable `a` is first assigned a list and then a string. This is possible because Python is dynamically typed. This dynamic typing allows for polymorphic behavior, where the same operation can do different things depending on the type of the object.
```python
def fetch_item(collection, position):
    return collection[position]

# This function can operate on various types, thanks to dynamic typing
fetch_item([1, 2, 3], 1)
fetch_item({'a': 1, 'b': 2}, 'b')
fetch_item("Python", 3)
```
In the above example, the `fetch_item()` function can operate on lists, dictionaries, and strings. This is possible because Python is dynamically typed and allows for polymorphic behavior.

### Operator Overloading/Function Overriding{#operator-overloading}
Operator overloading is another form of polymorphism. It allows you to define the behavior of an operator for a user-defined class. For example, you can define the behavior of the `+` operator for a class by implementing the `__add__()` or function `len()` method. This allows you to use the `+` operator with objects of that class.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

v1 = Vector(2, 10)
v2 = Vector(5, -2)
v3 = v1 + v2
print(v3.x)
print(v3.y)
----- ANS -----
7
8
```

By default, most of the built-ins and operators will not work with objects of your classes. You must add the corresponding special methods in your class definition to make your object compatible with built-ins and operators. This is exactly what the [Data Model (Section 3 of the Python documentation)](https://docs.python.org/3/reference/datamodel.html) helps you accomplish. It lists all the special methods available and provides you with the means of overriding built-in functions and operators so that you can use them on your own objects.


1. **EXAMAPLE `__len__`**

```python

class Order:
    def __init__(self, cart, customer):
   #def __init__(self, *args, customer): (another way to implement)
        self.cart = list(cart)
        #self.items = args
        self.customer = customer
        
    def __len__(self):
        return len(self.cart)
    
order = Order(['banana', 'apple', 'mango'], 'Ali Hejazizo')
len(order)

----- ANS -----
3
```
As you can see, you can now use `len()` to directly obtain the length of the cart. Moreover, it makes more intuitive sense to say “length of order” rather than calling something like `order.get_cart_len()`. Your call is both Pythonic and more intuitive. When you don’t have the `__len__()` method defined but still call `len()` on your object, you get a `TypeError`.

But, when overriding `len()`, you should keep in mind that Python requires the function to return an integer. If your method were to return anything other than an integer, you would get a `TypeError`. This, most probably, is to keep it consistent with the fact that `len()` is generally used to obtain the length of a sequence, which can only be an integer.


2. **EXAMAPLE `__abs__`**

```python
class Vector:
    def __init__(self, x_comp, y_comp):
        self.x_comp = x_comp
        self.y_comp = y_comp

    def __abs__(self):
        return (self.x_comp ** 2 + self.y_comp ** 2) ** 0.5
    
    vector = Vector(3, 4)
    abs(vector)

----- ANS -----
5

```

3. **EXAMAPLE `__str__` and `__repr__`**
The `str()` built-in is used to cast an instance of a class to a str object, or more appropriately, to obtain a user-friendly string representation of the object which can be read by a normal user rather than the programmer. You can define the string format your object should be displayed in when passed to `str()` by defining the `__str__()` method in your class. Moreover, `__str__()` is the method that is used by Python when you call `print()` on your object.

```python
class Vector:
    def __init__(self, x_comp, y_comp):
        self.x_comp = x_comp
        self.y_comp = y_comp

    def __str__(self):
        # By default, sign of +ve number is not displayed
        # Using `+`, sign is always displayed
        return f'{self.x_comp}i + {self.y_comp}j'
    def __repr__(self):
        return (f'{self.__class__.__name__}({self.x_comp}, {self.y_comp})'
                
vector = Vector(3, 4)
print(vector)

----- ANS -----
3i+4j
```
Read [Python String Conversion 101: Why Every Class Needs a “repr”](https://dbader.org/blog/python-repr-vs-str) for a complete tutorial on `__repr__` and the difference between `__repr__` and `__str__`.
[“Difference between `__str__` and `__repr__` in Python”](https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr) is a Stack Overflow question with excellent contributions from Pythonistas Alex Martelli and Martijn Pieters.

>Rule of thumb: `__repr__` is for developers, `__str__` is for customers.


4. **EXAMAPLE `__bool__`**:

```python

class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __bool__(self):
        return len(self.cart) > 0
    
order1 = Order(['banana', 'apple', 'mango'], 'Ali Hejazizo')
order2 = Order([], 'Mohsen')

bool(order1), bool(order2)

for order in [order1, order2]:
    if order:
        print(f"{order.customer}'s order is processing...")
    else:
        print(f"Empty order for customer {order.customer}")

----- ANS -----
(True, False)

Ali Hejazizo's order is processing...
Empty order for customer Mohsen

```
> **Note:** When the `__bool__()` special method is not implemented in a class, the value returned by `__len__()` is used as the truth value, where a non-zero value indicates True and a zero value indicates `False`. In case both the methods are not implemented, all instances of the class are considered to be `True`.

5. **EXAMAPLE `__add__`/`+`**:

Changing the behavior of operators is just as simple as changing the behavior of functions. You define their corresponding special methods in your class, and the operators work according to the behavior defined in these methods.

These are different from the above special methods in the sense that they need to accept another argument in the definition other than `self`, generally referred to by the name `other`. Let’s look at a few examples.

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __add__(self, other):
        new_cart = self.cart.copy()
        new_cart.append(other)
        return Order(new_cart, self.customer)
    
order = Order(["Apple"], "Ali")
(order + 'orange').cart  # New Order instance
order.cart  # Original instance unchanged
order = order + 'mango'  # Changing the original instance
order.cart

----- ANS -----
['Apple', 'orange']
['Apple']
['Apple', 'mango']
```
Similarly, you have the `__sub__()`, `__mul__()`, and other special methods which define the behavior of `-`, `*`, and so on. These methods should return a new instance of the class as well.

6. **EXAMAPLE `__getitem__`/Indexing/`[]`**:
The `[]` operator is called the indexing operator and is used in various contexts in Python such as getting the value at an index in sequences, getting the value associated with a key in dictionaries, or obtaining a part of a sequence through slicing. You can change its behavior using the `__getitem__()` special method.

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __getitem__(self, key):
        return self.cart[key]
    
    def __setitem__(self, key, value):
        self.items[key] = value
    
order = Order(['banana', 'apple'], 'Ali Hejazizo')
order[-1]
order[:]

----- ANS -----
'apple'
['banana', 'apple']
```

**Note:** There is a similar `__setitem__()` special method that is used to define the behavior of `obj[x] = y`. This method takes two arguments in addition to self, generally called key and value, and can be used to change the value at key to value.

You’ll notice that above, the name of the argument to `__getitem__()` is not index but key. This is because the argument can be of mainly three forms:
- **an integer value**: in which case it is either an index or a dictionary key
- **a string value**: in which case it is a dictionary key
- **a slice object**: in which case it will slice the sequence used by the class. While there are other possibilities, these are the ones most commonly encountered.

#### Special Methods{#special-methods}
| Method | Function |
|---|---|
|`__init__`| initializes an object after it is created |
|`__add__`| enables addition between two objects using the `+` operator |
|`__sub__`| enables subtraction between two objects using the `-` operator |
|`__mul__`| enables multiplication between two objects using the `*` operator |
|`__truediv__`| enables division between two objects using the `/` operator |
|`__floordiv__`| enables floor division between two objects using the `//` operator |
|`__mod__`| enables the modulo operation between two objects using the `%` operator |
|`__pow__`| enables the power operation between two objects using the `**` operator |
|`__neg__`| enables the negation of an object using the `-` operator |
|`__pos__`| enables the unary `+` operation on an object |
|`__abs__`| enables the absolute value of an object using the `abs()` function |
|`__len__`| enables the `len()` function to return the length of an object |
|`__str__`| enables the `str()` function to return a string representation of an object |
|`__repr__`| enables the `repr()` function to return a string representation of an object for debugging |
|`__bool__`| enables the `bool()` function to return a boolean value of an object |
|`__lt__`| enables the `<` operator to compare two objects |
|`__le__`| enables the `<=` operator to compare two objects |
|`__gt__`| enables the `>` operator to compare two objects |
|`__ge__`| enables the `>=` operator to compare two objects |
|`__eq__`| enables the `==` operator to compare two objects |
|`__ne__`| enables the `!=` operator to compare two objects |
|`__contains__`| enables the `in` operator to check if an object contains another object |
|`__getitem__`| enables the indexing operator `[]` to access an element in a sequence |
|`__setitem__`| enables the indexing operator `[]` to set the value of an element in a sequence |
|`__delitem__`| enables the deletion of an element in a sequence using the `del` statement |


> **Note:** Reflected arithmetic operators are used when the left operand does not support the operation. For example, if the left operand does not support addition, Python will try to call the `__radd__()` method of the right operand. If the right operand does not support addition either, Python will raise a `TypeError`.
> **Note:** Augmented assignment operators are used to perform an operation and assign the result back to the left operand. For example, `a += b` is equivalent to `a = a + b`. These operators are implemented using special methods like `__iadd__()`, `__isub__()`, and so on.
## Encapsulation{#encapsulation}
Encapsulation is an object-oriented programming concept that binds together the data and functions that manipulate the data and that keeps both safe from outside interference and misuse. Data encapsulation led to the important OOP concept of data hiding.


Python does not have the private keyword, unlike some other object-oriented languages, but encapsulation can be done using naming conventions. 
- **Public Attributes/Methods:** By default, all members of a Python class are `public`, meaning they can be accessed from **anywhere** in the code.
- **Protected Attributes/Methods:** Indicated by a single underscore prefix `_`, these are intended for internal use **by the class and its subclasses.** This is more of a convention than a strict rule and serves as a hint to other developers.
- **Private Attributes/Methods:** Denoted by a double underscore prefix `__`, these members are name-mangled to make them harder (but not impossible) to access from outside the class. **This mechanism doesn't fully prevent access from outside but acts as a stronger suggestion that such members are intended for internal use only**.


The roles of encapsulation are as follows:
- **Data Protection:** The internal state of an object of a class is protected from the outside world. The object’s state can be accessed only through the methods of the class. This is achieved by making the data private to the class and providing public methods to access or modify the data.
- **Data Hiding:** The internal state of an object is hidden from the outside world. The object’s state can be accessed only through the methods of the class. This is achieved by making the data private to the class and providing public methods to access or modify the data.
- **Code Modularity:** The internal state of an object is hidden from the outside world. The object’s state can be accessed only through the methods of the class. This is achieved by making the data private to the class and providing public methods to access or modify the data.

1. Example of protected attributes/methods:

```python   
class Vehicle:
    def __init__(self, make, fuel_capacity):
        self.make = make  # Vehicle's make as a public attribute
        self._fuel_capacity = fuel_capacity  # Protected attribute
        self._fuel_level = fuel_capacity  # Protected attribute: starts full

    def _consume_fuel(self, amount):  # Protected method
        self._fuel_level -= amount
        if self._fuel_level < 0:
            self._fuel_level = 0
        print(f"Fuel left in {self.make}: {self._fuel_level} liters")

class Sedan(Vehicle):
    def drive(self, distance):
        print(f"Driving the sedan for {distance} miles.")
        fuel_consumption_rate = 0.04  # Example: Consumes 0.04 liters per mile
        self._consume_fuel(distance * fuel_consumption_rate)

class SUV(Vehicle):
    def drive(self, distance):
        print(f"Driving the SUV for {distance} miles.")
        fuel_consumption_rate = 0.07  # Example: Consumes 0.07 liters per mile
        self._consume_fuel(distance * fuel_consumption_rate)

# Creating instances
toyota_camry = Sedan("Toyota Camry", 60)
ford_explorer = SUV("Ford Explorer", 70)
# Driving the cars
toyota_camry.drive(200)

ford_explorer.drive(200)
---- ANS ----
Driving the sedan for 200 miles.
Fuel left in Toyota Camry: 52.0 liters

Driving the SUV for 200 miles.
Fuel left in Ford Explorer: 56.0 liters
```
In the above example, the `_fuel_capacity` and `_fuel_level` attributes are protected attributes, and the `_consume_fuel()` method is a protected method. These members are intended for internal use by the class and its subclasses. The `Sedan` and `SUV` classes inherit from the `Vehicle` class and use the protected attributes and method to implement the `drive()` method.
While `_` is just a convention, it is a strong hint to other developers that these members are intended for internal use only. It is not enforced by the Python interpreter, and you can still access protected members from outside the class. However, it is a good practice to follow this convention to avoid accidental misuse of protected members.

2. Example Private attributes/methods:

```python
class Account:
    def __init__(self, owner, balance):
        self.owner = owner             # Public attribute
        self.__balance = balance       # Private attribute

    def __update_balance(self, amount):  # Private method
        self.__balance += amount
        return self.__balance

    def deposit(self, amount):
        if amount > 0:
            new_balance = self.__update_balance(amount)
            print(f"Deposit successful. New balance: {new_balance}")
        else:
            print("Deposit amount must be positive.")

# Creating an instance of Account
my_account = Account("John Doe", 1000)

# Trying to access private members from outside the class
my_account.__balance  # This will raise an AttributeError
my_account.deposit(500)  # This works as intended
---- ANS ----
AttributeError: 'Account' object has no attribute '__balance'

Deposit successful. New balance: 1500
```
In the above example, the `__balance` attribute and the `__update_balance()` method are private members of the `Account` class. These members are intended for internal use by the class only. The `deposit()` method is a public method that allows you to deposit money into the account. You cannot access private members from outside the class, and attempting to do so will raise an `AttributeError`.

## Method Types{#method-types}
In Python, methods are categorized into three types:
- **Instance Methods:** These are the most common type of methods in Python classes. They take `self` as the first argument, which represents the instance of the class. Instance methods can access and modify the instance state.
  - They are your go-to for most functionality affecting individual objects.
- **Class Methods:** These methods are bound to the class rather than the object of the class. They can modify the class state that applies across all instances of the class. Class methods take `cls` as the first argument, which represents the class itself. Class methods are decorated with `@classmethod`.
  - It help organize utility functions related to a class but that don't necessarily need access to its instances or class attributes.
  - 
  ```python
    class Person:
        count = 0  # Class attribute
    
        def __init__(self):
            Person.count += 1
    
        @classmethod
        def display_count(cls):
            return cls.count
  ```
- **Static Methods:** These methods don't take `self` or `cls` as the first argument. They behave like regular functions but belong to the class's namespace. Static methods are marked with the `@staticmethod` decorator. We use them when a method in a class doesn't use or modify the class or its instances.
  - They are powerful tools for modifying class attributes - hence affecting all instances, and can also serve as alternative constructors.
  - To use static method, you don't need an instance of the class. `<class name>.<static method name>`
  - 
  ```python
    class TemperatureConverter:
        @staticmethod
        def celsius_to_fahrenheit(celsius):
            return (celsius * 9/5) + 32

    celsius_temp = 25
    fahrenheit_temp = TemperatureConverter.celsius_to_fahrenheit(celsius_temp)
    ```