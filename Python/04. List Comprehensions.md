# Comprehensions
<a class="anchor" id="comprehension"></a>

Comprehensions in Python are a compact, readable way to create new sequences (such as lists, sets, or dictionaries) by applying an expression to each item in an iterable. Iterables are objects that Python can loop over, such as lists, tuples, dictionaries, sets, and strings.

The general form of a comprehension is:

- for lists: `[expression for item in iterable]`
- for sets: `{expression for item in iterable}`
- for dictionaries: `{key_expression: value_expression for item in iterable}`

>**Note**: We can also use comprehension to create an iteration to iterate over a list item
```python
    import itertools
    g = itertools.cycle([10,10,2,2])
    next(g)
    --- ANS ---
    10
```

## List Comprehensions{#list_comprehensions}
List comprehensions provide a concise way to create lists.
```python
    squares = []
    for i in range(10):
        squares.append(i * i)
    squares
    --- ANS ---
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```
**Better Solution** for the above example is using **list comprehension**:
```python
squares=[item * item for item in range(10)]
squres
--- ANS ---
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```
Here are some examples of list comprehensions in Python:

- Nested Loops in list comprehension:
    ```python
    matrix = [[1, 2], [3, 4], [5, 6]]
    items = [item for row in matrix for item in row]
    items
    --- ANS ---
    [1, 2, 3, 4, 5, 6]
    ```
- Using conditional logic in list comprehension:
    ```python
    original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
    prices = [i if i > 0 else 0 for i in original_prices]
    prices
    --- ANS ---
    [1.25, 0, 10.22, 3.78, 0, 1.16]
    ```
- Using a function in list comprehension:
    ```python
    def square(x):
        return x * x
    
    numbers = [2, 3, 5, 7]
    squares = [square(i) for i in numbers]
    squares
    --- ANS ---
    [4, 9, 25, 49]
    ```
- Creating empty lists: Rather than creating an empty list and adding each element to the end, you simply define the list and its contents at the same time by following this format:
    ```python
    empty_list = [expression for item in iterable]
    ```    

Every list comprehension in Python includes three elements:

- **expression** is the member itself, a call to a method, or any other valid expression that returns a value. In the example above, the expression `i * i` is the square of the member value.
- **member** is the object or value in the list or iterable. In the example above, the member value is `i`.
- **iterable** is a list, set, sequence, generator, or any other object that can return its elements one at a time. In the example above, the iterable is `range(10)`.

## Set Comprehensions{#set_comprehensions}
Set comprehensions are similar to list comprehensions. The key difference is that sets do not allow duplicate values and are unordered, while lists can contain duplicates and maintain order. Also, set comprehensions use curly braces `{}`. Here’s an example:

```python
quote = "life, uh, finds a way"
unique_vowels = {i for i in quote if i in 'aeiou'}
unique_vowels
--- ANS ---
{'a', 'e', 'i', 'u'}
```

## Dictionary Comprehensions{#dictionary_comprehensions}
Dictionary comprehensions are similar, but you also need to include a key expression. You use curly braces `{}` and colons `:` to signify key-value pairs. Here’s an example:

```python   
squares = {i: i * i for i in range(10)}
squares
--- ANS ---
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
```
- Dictionary comprehensions with condition: You can also filter the items in a dictionary comprehension with a conditional expression
  ``` python
    even_squares_dict = {x: x**2 for x in range(10) if x % 2 == 0}
    even_squares_dict
    ---- ANS ----
    {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
  ```
- iterating over keys, values, or items in a dictionary
  ```python
    my_dict = {'a': 1, 'b': 2, 'c': 3}
    inverted_dict = {value: key for key, value in my_dict.items()}
    inverted_dict
    ---- ANS ----
    {1: 'a', 2: 'b', 3: 'c'}
  ```
- Dictionary comprehension with zip function:
    ```python
    keys = ['a', 'b', 'c']
    values = [1, 2, 3]
    my_dict = {k: v for k, v in zip(keys, values)}
    my_dict
    ---- ANS ----
    {'a': 1, 'b': 2, 'c': 3}
    ```

## Using `map()` object
`map()` provides an alternative approach that’s based in functional programming. You pass in a function and an iterable, and `map()` will create an object. This object contains the output you would get from running each iterable element through the supplied function.

- First Example: 

    ```python
    def func(a):
        return a**2

    x = map(func, [1,2,5])
    next(x)
    ans=[1, 4, 25]
    ----- ANS -----
    1
    ```
- Second Example:

    ```python
    list(map(str.upper, ('ali', 'reza', 'gholi')))
    ans = ['ALI', 'REZA', 'GHOLI']
    ```
- Third Example (very efficient):
    ```python
    x = map(func, range(100000000)
    next(x)
    ---- ANS ----
    0
    ```

## Using Conditional Logic
The most common way to add conditional logic to a list comprehension is to add a conditional to the end of the expression:

```python
new_list = [expression for member in iterable (if conditional)]
```

- Example:
    ```python
    sentence = 'the rocket came back from mars'
    vowels = [i for i in sentence if i in 'aeiou']
    vowels
    ```

You can place the conditional at the end of the statement for simple filtering, but what if you want to change a member value instead of filtering it out? In this case, it’s useful to place the conditional near the beginning of the expression:

```python
new_list = [expression (if conditional) for member in iterable]
```
- Example:

    ```python
    original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
    prices = [i if i > 0 else 0 for i in original_prices]
    prices
    ```



## Best Practices{#best_practices}
Keeping Comprehensions **Readable** and **Maintainable**
- **Simplicity:** Keep the expressions in comprehensions simple. If the logic gets too complicated, consider using a function or breaking down the problem differently.
Line Length: Follow the PEP 8 recommendation of a maximum line length (79 characters is the default). If a comprehension is too long, it might be less readable.
- **Nested Comprehensions:** Use nested comprehensions sparingly, as they can quickly become difficult to read. If you have nested comprehensions, ensure that each one is simple.
- **Variable Names:** Use descriptive variable names for the items in the iterable, so it's clear what each part of the comprehension is doing.
  
By following these best practices and being mindful of the potential pitfalls, you can leverage the power of comprehensions in Python effectively while maintaining clean, readable, and efficient code

**When to Use Comprehensions:**

- When you need a concise and clear way to transform one iterable into another.
- When the transformation logic is simple and can be expressed in a single line.
- When applying a function to each item in an iterable.
- When you need to filter items from a sequence based on a condition.
- When you want to leverage the speed and efficiency benefits provided by comprehensions.

**When Not to Use Comprehensions:**

- When the logic is too complex and would lead to a comprehension that is difficult to understand. In such cases, a traditional loop might be more readable.
- When the comprehension would span multiple lines and reduce clarity. Readability counts.
- When the expression involves side effects, such as modifying external variables or performing I/O operations. Comprehensions should be used for their return values, not for side effects.
- When you need to debug the transformation process, as comprehensions can be less straightforward to step through with a debugger
  
